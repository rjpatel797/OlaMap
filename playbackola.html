<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>GPS Playback System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- jQuery for API requests -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- Ola Maps SDK and custom styles -->
  <link href="olamap/style.css" rel="stylesheet" />
  <script src="olamap/olamaps-js-sdk.umd.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body,
    html {
      height: 100%;
      font-family: Arial, sans-serif;
    }

    /* Container setup for full layout */
    .container {
      display: flex;
      flex-direction: column;
      height: 92vh;
    }

    /* Navbar styles */
    #navbar-container {
      width: 100%;
      background-color: #333;
      color: white;
      padding: 0;
    }

    /* Flex layout for main content */
    .content {
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
    }

    #map {
      width: 100%;
      height: 725px;
    }

    .controls {
      margin: 3px;
      background: #2c3e50;
      /* Matching navbar background */
      padding: 5px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      gap: 5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* .controls button {
        padding: 5px 15px;
        font-size: 8px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      } */

    .controls {
      margin: 3px;
      background: #2c3e50;
      padding: 10px;
      border-radius: 8px;
      display: flex;
      gap: 15px;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .datetime-selector {
      align-items: center;
      display: flex;
      gap: 10px;
    }

    .date-input {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .date-input label {
      color: white;
      font-size: 13px;
      font-weight: 500;
    }

    .date-input input[type="date"] {
      padding: 5px 8px;
      border: none;
      border-radius: 4px;
      font-size: 13px;
      color: #2c3e50;
      background-color: white;
      cursor: pointer;
      outline: none;
    }

    .date-input input[type="date"]:hover {
      background-color: #f8f9fa;
    }

    .date-input input[type="date"]:focus {
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
    }

    .datetime-wrapper {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .date-input input[type="time"] {
      padding: 5px 8px;
      border: none;
      border-radius: 4px;
      font-size: 13px;
      color: #2c3e50;
      background-color: white;
      cursor: pointer;
      outline: none;
      height: 31px;
    }

    .date-input input[type="time"]:hover {
      background-color: #f8f9fa;
    }

    .date-input input[type="time"]:focus {
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
    }

    .device-selector select {
      padding: 5px 25px 5px 10px;
      font-size: 13px;
      color: #2c3e50;
      background-color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%232c3e50' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 12px;
      min-width: 150px;
    }

    .device-selector select:hover {
      background-color: #f8f9fa;
    }

    .device-selector select:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
    }

    .buttonclass {
      display: flex;
      gap: 8px;
    }

    /* Keep your existing button styles */
    .buttonclass button {
      padding: 8px 16px;
      font-size: 13px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    /* Start Button */
    #startPlayback {
      background-color: #2ecc71;
      color: white;
    }

    #startPlayback:hover {
      background-color: #27ae60;
    }

    /* Pause Button */
    #pausePlayback {
      background-color: #f1c40f;
      color: #2c3e50;
    }

    #pausePlayback:hover {
      background-color: #f39c12;
    }

    /* Stop Button */
    #stopPlayback {
      background-color: #e74c3c;
      color: white;
    }

    #stopPlayback:hover {
      background-color: #c0392b;
    }

    /* Add icons to buttons */
    #startPlayback::before {
      content: "‚ñ∂";
      font-size: 12px;
    }

    #pausePlayback::before {
      content: "‚è∏";
      font-size: 12px;
    }

    #stopPlayback::before {
      content: "‚èπ";
      font-size: 12px;
    }

    /* Active state for buttons */
    .controls button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    /* Disabled state */
    .controls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    @media (max-width: 768px) {
      .controls {
        margin: 10px;
        padding: 10px;
      }

      .controls button {
        padding: 8px 16px;
        font-size: 12px;
      }
    }

    .customMarkerClass {
      display: none;
      margin-top: 10px;
      height: 20px;
      width: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      /* Keep marker below popup */
    }

    .carImage {
      width: 40px;
      height: 20px;
    }

    #customPopup {
      position: absolute;
      background: #fff;
      padding: 15px 20px;
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.15);
      display: none;
      z-index: 1000;
      /* Ensure popup stays above marker */
      min-width: 280px;
      text-align: left;
      transform: translate(-50%, -100%);
      /* Center horizontally and move up */
      margin-top: -20px;
      /* Add extra space between popup and marker */
    }

    /* Update arrow position */
    .popup::after {
      content: "";
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid #fff;
      filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.1));
    }

    #popupContent {
      line-height: 1.8;
      color: #2c3e50;
      font-size: 13px;
    }

    #popupContent b {
      color: #34495e;
      width: 100px;
      display: inline-block;
      font-weight: 600;
    }

    /* Status indicators */
    .status-indicator {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 500;
      margin-left: 5px;
    }

    .status-on {
      background-color: #2ecc71;
      color: white;
    }

    .status-off {
      background-color: #e74c3c;
      color: white;
    }

    /* Popup styling */
    .popup {
      position: absolute;
      background: white;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.2);
      display: none;
      z-index: 1000;
      min-width: 280px;
      text-align: left;
      transform: translateX(-50%);
      /* Center the popup horizontally */
    }

    .popup .close-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      cursor: pointer;
      color: #95a5a6;
      font-size: 16px;
      transition: color 0.2s ease;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }

    .popup .close-btn:hover {
      color: #34495e;
      background: #f5f6f7;
    }

    /* Arrow indicator */
    /* .popup::after {
    content: "";
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid #fff;
    filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.1));
} */

    .controls {
      margin: 3px;
      background: #2c3e50;
      padding: 5px 15px;
      /* Increased padding */
      border-radius: 8px;
      display: flex;
      gap: 10px;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .selected-device {
      margin-left: 15px;
      padding: 5px 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      color: white;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      min-width: 200px;
    }

    .device-icon {
      font-size: 16px;
    }

    #deviceNameDisplay {
      font-weight: 500;
      color: #ecf0f1;
    }

    .deviceItem {
      position: relative;
      background-color: #f5f6f7;
      border-radius: 6px;
      margin: 5px 0;
      transition: all 0.3s ease;
    }

    .device-main {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      cursor: pointer;
    }

    .device-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dropdown-arrow {
      font-size: 10px;
      color: #666;
      transition: transform 0.3s ease;
    }

    .device-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: white;
      border-radius: 0 0 6px 6px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s ease;
      z-index: 100;
    }

    .device-selector {
      position: relative;
      margin-left: 10px;
    }

    #deviceSelect {
      padding: 5px 35px 5px 15px;
      font-size: 13px;
      color: #fff;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      min-width: 200px;
      height: 32px;
      outline: none;
      transition: all 0.3s ease;
    }

    #deviceSelect:hover {
      background-color: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    #deviceSelect:focus {
      background-color: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .device-selector::after {
      content: "‚ñº";
      font-size: 10px;
      color: #000;
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
    }

    #deviceSelect option {
      background-color: #2c3e50;
      color: #fff;
      padding: 8px;
    }

    #deviceSelect option:hover {
      background-color: #34495e;
    }

    /*speed control*/
    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 5px;
      background: #f5f5f5;
      border-radius: 4px;
    }

    .speed-slider {
      flex-grow: 1;
      height: 3px;
      /* -webkit-appearance: none; */
      background: #ddd;
      border-radius: 5px;
      outline: none;
      max-width: 65px;
    }

    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 5px;
      height: 5px;
      background: #4caf50;
      border-radius: 50%;
      cursor: pointer;
    }

    .speed-label {
      min-width: 30px;
      text-align: center;
      font-size: 12px;
    }

    .speed-buttons {
      display: flex;
      gap: 5px;
    }

    .speed-btn {
      padding: 5px 10px;
      border: none;
      background: #4caf50;
      color: white;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
    }

    .speed-btn:hover {
      background: #45a049;
    }

    /* Adjust the existing controls styles */
    .controls {
      margin: 3px;
      background: #2c3e50;
      padding: 5px 15px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .controls .buttonclass {
      padding: 8px 16px;
      font-size: 13px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    #startPlayback {
      background-color: #2ecc71;
      color: white;
    }

    #startPlayback:hover {
      background-color: #27ae60;
    }

    #pausePlayback {
      background-color: #f1c40f;
      color: #2c3e50;
    }

    #pausePlayback:hover {
      background-color: #f39c12;
    }

    #stopPlayback {
      background-color: #e74c3c;
      color: white;
    }

    #stopPlayback:hover {
      background-color: #c0392b;
    }

    .device-selector {
      position: relative;
      width: 140px;
    }

    .dropdown-container {
      position: relative;
    }

    .dropdown-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      display: none;
      z-index: 1000;
    }

    .dropdown-header {
      padding: 10px;
      color: rgb(0, 0, 0);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      font-weight: 500;
    }

    .dropdown-search {
      padding: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .dropdown-search input {
      width: 100%;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 4px;
      color: rgb(0, 0, 0);
      font-size: 13px;
    }

    .dropdown-items {
      max-height: 200px;
      overflow-y: auto;
    }

    .dropdown-item {
      padding: 8px 10px;
      color: black;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .dropdown-item:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    .selected-vehicle {
      padding: 8px 12px;
      background: #f8f9fa;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: rgb(0, 0, 0);
      cursor: pointer;
      font-size: 13px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .selected-vehicle:after {
      content: "‚ñº";
      font-size: 10px;
      margin-left: 8px;
    }

    /*over speeding*/
    .speed-threshold-container {
    display: flex;
    align-items: center;
    gap: 5px;
    background: linear-gradient(145deg, #1e242c, #1a1f25);
    padding: 5px 6px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.05);
      color: #e6edf3;
      color: #e6edf3;
      font-size: 13px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    color: #e6edf3;
      font-size: 13px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.speed-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 25px;
    background: #dc2626;
    border-radius: 6px;
    padding: 5px;
    transition: all 0.3s ease;
}

.speed-icon svg {
    width: 16px;
    height: 16px;
    stroke: white;
}

.speed-select-wrapper {
    position: relative;
}

.speed-dropdown {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    color: #fff;
    font-size: 13px;
    padding: 6px 25px 6px 10px;
    appearance: none;
    cursor: pointer;
    min-width: 120px;
    backdrop-filter: blur(8px);
    background: linear-gradient(145deg, rgba(29, 36, 44, 0.8), rgba(25, 31, 37, 0.8));
}

.speed-dropdown:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(220, 38, 38, 0.5);
}

.speed-dropdown:focus {
    outline: none;
    border-color: #dc2626;
    box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.25);
}

.speed-dropdown option {
    background-color: #1a1f25;
    color: #fff;
    padding: 8px;
}

.speed-select-wrapper::after {
    content: '';
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 10px;
    height: 10px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-size: contain;
    background-repeat: no-repeat;
    pointer-events: none;
}

.speed-label {
    font-weight: 500;
    font-size: 13px;
    color: #e6edf3;
    white-space: nowrap;
}

    /* Add these styles to your existing CSS */
    .polyline-popup {
      display: none;
      position: absolute;
      background: white;
      padding: 8px 12px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      color: #333;
      max-width: 200px;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .polyline-popup::after {
      content: "";
      position: absolute;
      bottom: -5px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid white;
    }

    /* pop-up display righ-side*/
    .vehicle-info-popup {
      position: fixed;
      top: 160px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;  /* Reduced from 15px */
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      width: 180px;  /* Reduced from 280px */
      z-index: 9999;
      transition: all 0.3s ease;
    }

    .info-container {
      display: flex;
      flex-direction: column;
      gap: 3px;  /* Reduced from 12px */
    }

    .info-card {
      display: flex;
      align-items: center;
      padding: 3px;  /* Reduced from 10px */
      background: white;
      border-radius: 10px;
      transition: transform 0.2s ease;
      border: 1px solid #f0f0f0;
    }

    .info-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .info-icon {
      font-size: 16px;  /* Reduced from 20px */
      width: 30px;  /* Reduced from 40px */
      height: 30px;  /* Reduced from 40px */
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f9fa;
      border-radius: 8px;
      margin-right: 8px;  /* Reduced from 12px */
    }

    .info-details {
      display: flex;
      flex-direction: column;
      gap: 2px;  /* Reduced from 4px */
    }

    .info-label {
      color: #64748b;
      font-size: 11px;  /* Reduced from 12px */
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .info-value {
      color: #1e293b;
      font-size: 13px;  /* Reduced from 16px */
      font-weight: 600;
    }

    #speedDisplay {
      color: #2563eb;
    }

    #dateTimeDisplay {
      font-size: 12px;  
      white-space: nowrap;
    }

    #distanceDisplay {
      color: #059669;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .vehicle-info-popup {
        width: calc(100% - 40px);
        top: auto;
        bottom: 20px;
        right: 20px;
      }
      
      .info-container {
        flex-direction: row;
        justify-content: space-between;
      }
      
      .info-card {
        flex: 1;
      }
    }

    .start-time-popup {
      position: fixed;
      top: 70px;
      /* Adjust this value to position it where you want */
      right: 20px;
      background: white;
      padding: 8px 12px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      font-size: 14px;
    }

    .start-time-content {
      white-space: nowrap;
    }

    .hold-time-selector {
      display: flex;
      align-items: center;
      gap: 10px;
      color: white;
      font-size: 13px;
    }

    .hold-time-selector select {
      padding: 5px 10px;
      border-radius: 4px;
      background-color: white;
      color: #2c3e50;
      border: none;
      outline: none;
      cursor: pointer;
    }

    .buttonclass button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background-color: #cccccc;
    }

    .stop-popup {
      position: relative;
      /* Change from absolute to relative */
      background: #fff;
      padding: 15px 20px;
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.15);
      display: none;
      z-index: 1000;
      max-width: 450px;
      text-align: left;
    }

    /* Add arrow at bottom of popup */
    .stop-popup::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid #fff;
    }

    .hold-time-selector {
    display: flex;
    align-items: center;
    gap: 5px;
    background: #fff;
    padding: 5px 6px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.05);
    color: #e6edf3;
    width: 150px;
}

.hold-time-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 25px;
    background: #3b82f6;
    border-radius: 6px;
    padding: 5px;
}

.hold-time-icon svg {
    width: 16px;
    height: 16px;
    stroke: white;
}

.hold-time-select {
    background: #fff;
    border: 2px solid rgba(0, 0, 0, 0.1);
    border-radius: 6px;
    color: #fff;
    font-size: 12px;
    padding: 6px 0px 6px 0px;
    appearance: none;
    cursor: pointer;
    min-width: 100px;
    backdrop-filter: blur(8px);
    background: #fff;
}

.hold-time-select:hover {
    background: #fff;
    border-color: rgba(59, 130, 246, 0.5);
}

.hold-time-select:focus {
    outline: none;
    border-color: #3b82f6;
    border: 2px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
}

.hold-time-select option {
    background-color: #fff;
    color: #303430;
    padding: 8px;
}

.hold-time-wrapper {
    position: relative;
    border: 2px solid rgba(0, 0, 0, 0.1);
    border-radius: 6px;
}

.hold-time-wrapper::after {
    content: '';
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 10px;
    height: 10px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23000000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-size: contain;
    background-repeat: no-repeat;
    pointer-events: none;
}
  </style>
</head>

<body>
  <div class="container">
    <!-- Navbar -->
    <div id="navbar-container"></div>
    <div class="content">
      <div class="controls">
        <div class="device-selector">
          <div class="dropdown-container">
            <div class="selected-vehicle" id="selectedVehicle" onclick="toggleDropdown()">
              Select Vehicle
            </div>
            <div class="dropdown-list" id="deviceDropdown">
              <div class="dropdown-search">
                <input type="text" placeholder="Search vehicle..." id="vehicleSearch"
                  onclick="event.stopPropagation()" onkeyup="filterVehicles(this.value)" />
              </div>
              <div class="dropdown-items" id="vehicleList"></div>
            </div>
          </div>
        </div>

        <div class="datetime-selector">
          <div class="date-input">
            <label>From:</label>
            <div class="datetime-wrapper">
              <input type="date" id="fromDate" placeholder="dd/mm/yyyy" />
              <input type="time" id="fromTime" value="00:00" />
            </div>
          </div>
          <div class="date-input">
            <label>To:</label>
            <div class="datetime-wrapper">
              <input type="date" id="toDate" placeholder="dd/mm/yyyy" />
              <input type="time" id="toTime" value="23:59" />
            </div>
          </div>

          <div class="speed-control">
            <div class="speed-buttons">
              <button class="speed-btn" onclick="decreaseSpeed()">-</button>
              <button class="speed-btn" onclick="increaseSpeed()">+</button>
            </div>
            <input type="range" min="0.25" max="8" step="0.25" value="1" class="speed-slider" id="speedSlider"
              onchange="updateSpeed(this.value)" />
            <div class="speed-label" id="speedLabel" style="color: #000;">1x</div>
          </div>
        </div>

        <!-- Add this inside your controls section, near other controls -->
        <div class="speed-threshold-container">
          <div class="speed-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41M12 10.5l3.5 4.5h-7z"/>
                  <circle cx="12" cy="12" r="10"/>
              </svg>
          </div>
          <div class="speed-select-wrapper">
              <select id="overSpeedingThreshold" class="speed-dropdown">
                  <option value="30">30 km/h</option>
                  <option value="40">40 km/h</option>
                  <option value="45">45 km/h</option>
                  <option value="50" selected>50 km/h</option>
                  <option value="60">60 km/h</option>
                  <option value="65">65 km/h</option>
                  <option value="70">70 km/h</option>
                  <option value="75">75 km/h</option>
                  <option value="80">80 km/h</option>
                  <option value="85">85 km/h</option>
                  <option value="90">90 km/h</option>
                  <option value="95">95 km/h</option>
                  <option value="100">100 km/h</option>
                  <option value="120">120 km/h</option>
              </select>
          </div>
      </div>

        <div class="hold-time-selector">
          <div class="hold-time-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="10"/>
                  <polyline points="12 6 12 12 16 14"/>
              </svg>
          </div>
          <div class="hold-time-wrapper">
              <select class="hold-time-select" id="holdTime">
                  <option value="2">2 Minutes</option>
                  <option value="3">3 Minutes</option>
                  <option value="5">5 Minutes</option>
                  <option value="10">10 Minutes</option>
                  <option value="15">15 Minutes</option>
                  <option value="20">20 Minutes</option>
                  <option value="30" selected>30 Minutes</option>
                  <option value="45">45 Minutes</option>
                  <option value="60">1 Hour</option>
                  <option value="90">1.5 Hours</option>
                  <option value="120">2 Hours</option>
              </select>
          </div>
      </div>

        <div class="buttonclass">
          <button id="startPlayback">Start</button>
          <button id="pausePlayback">Pause</button>
          <button id="stopPlayback">Stop</button>
        </div>
      </div>
      <div id="map"></div>

      <!-- Custom Popup Element -->
      <div id="customPopup" class="popup">
        <span class="close-btn" onclick="hidePopup(true)">‚úñ</span>
        <div id="popupContent"></div>
      </div>

      <div id="stopMarkerPopup" class="popup stop-popup">
        <span class="close-btn" onclick="hideStopPopup(true)">‚úñ</span>
        <div id="stopPopupContent"></div>
      </div>

      <div id="polylinePopup" class="polyline-popup">
        <div id="polylinePopupContent"></div>
      </div>
    </div>

    <div id="vehicleInfoPopup" class="vehicle-info-popup">
      <div class="info-container">
        <div class="info-card">
          <div class="info-icon">üöó</div>
          <div class="info-details">
            <span class="info-label">Speed</span>
            <span class="info-value" id="speedDisplay">0 km/h</span>
          </div>
        </div>
        
        <div class="info-card">
          <div class="info-icon">üïí</div>
          <div class="info-details">
            <span class="info-label">Time</span>
            <span class="info-value" id="dateTimeDisplay">--</span>
          </div>
        </div>
        
        <div class="info-card">
          <div class="info-icon">üìç</div>
          <div class="info-details">
            <span class="info-label">Distance</span>
            <span class="info-value" id="distanceDisplay">0 km</span>
          </div>
        </div>
      </div>
    </div>

  </div>

  <script src="js/api.js"></script>
  <script>
    // Initialize the Ola Maps SDK
    const olaMaps = new OlaMapsSDK.OlaMaps({
      apiKey: "0OiYwalFPHxDTgjBQlXOtUj9S70okyKvaJ02wBf9",
    });

    // Initialize map
    const myMap = olaMaps.init({
      style:
        "https://api.olamaps.io/tiles/vector/v1/styles/default-light-standard/style.json",
      container: "map",
      center: [72.5714, 23.0225],
      zoom: 15,
    });

    let vehicleMarker = null;
    let startingMarker = null;
    let playbackData = [];
    let index = 0;
    let playbackInterval = null;
    let isPaused = false;
    const polylineId = "dynamicPolyline";
    let dynamicPlaybackData = [];
    let isPopupClosedManually = false;
    let deviceData = [];
    let speedThreshold = 30;
    let fetching = false;
    const MINIMUM_DISTANCE = 0.01; // km - threshold for considering vehicle stopped
    let polylinePopup = null;


    const ANGLE_OFFSET = 90;
    const popup = document.getElementById("customPopup");
    const popupContent = document.getElementById("popupContent");

    myMap.on("load", () => {
      console.log("Map loaded");
      fetchDeviceData();
    });

    let devices = [];

    function toggleDropdown() {
      const dropdown = document.getElementById("deviceDropdown");
      dropdown.style.display =
        dropdown.style.display === "block" ? "none" : "block";
    }

    function filterVehicles(searchText) {
      const filteredDevices = devices.filter((device) =>
        device.name.toLowerCase().includes(searchText.toLowerCase())
      );
      populateVehicleList(filteredDevices);
    }

    function selectVehicle(deviceId, deviceName) {
      document.getElementById("selectedVehicle").textContent = deviceName;
      document.getElementById("deviceDropdown").style.display = "none";
      fetchPlaybackData(deviceId);
    }

    function populateVehicleList(devicesList) {
      const vehicleList = document.getElementById("vehicleList");
      vehicleList.innerHTML = "";

      devicesList.forEach((device) => {
        const item = document.createElement("div");
        item.className = "dropdown-item";
        item.textContent = device.name;
        item.onclick = () => selectVehicle(device.did, device.name);
        vehicleList.appendChild(item);
      });
    }

    function fetchDeviceData() {
      const mid = localStorage.getItem("mid");
      fetch(`${API}opr=getdevicelistByMid&mid=${mid}`)
        .then((response) => response.json())
        .then((data) => {
          devices = data.map((item) => ({
            name: item.dname,
            did: item.did,
          }));
          populateVehicleList(devices);
          deviceData = devices;
        })
        .catch((error) => console.error("Error fetching vehicle:", error));
    }

    document.addEventListener("click", function (event) {
      const dropdown = document.getElementById("deviceDropdown");
      if (!event.target.closest(".device-selector")) {
        dropdown.style.display = "none";
      }
    });

    // Then update your JavaScript
    function createDeviceList() {
      const deviceSelect = $("#deviceSelect");
      deviceSelect.empty().append('<option value="">Select Vehicle</option>');

      devices.forEach((device) => {
        deviceSelect.append(`
            <option value="${device.did}">
                ${device.name}
            </option>
        `);
      });

      // Add change event handler
      deviceSelect.on("change", function () {
        const selectedDid = $(this).val();
        const selectedDevice = devices.find((d) => d.did == selectedDid);

        if (selectedDevice) {
          $("#deviceNameDisplay").text(selectedDevice.did);
          fetchPlaybackData(selectedDid);
        }
      });
    } // Fetch playback data from API

    function updateStartButtonState() {
      const startButton = document.getElementById("startPlayback");
      startButton.disabled = fetching;

      // Optionally update button appearance when disabled
      if (fetching) {
        startButton.style.opacity = "0.6";
        startButton.style.cursor = "not-allowed";
      } else {
        startButton.style.opacity = "1";
        startButton.style.cursor = "pointer";
      }
    }

    function formatTime(timeString) {
      return timeString.replace(":", "") + "00";
    }

    function fetchPlaybackData(did) {
      stopPlayback();
      console.log("Fetching playback data...");
      fetching = true;
      updateStartButtonState();

      // Get values from date inputs
      const fromDate = document.getElementById("fromDate").value;
      const toDate = document.getElementById("toDate").value;
      const fromTime = document.getElementById("fromTime").value || "00:00";
      const toTime = document.getElementById("toTime").value || "23:59";
      // Validate dates
      if (!fromDate || !toDate) {
        alert("Please select both From and To dates");
        fetching = false;
        updateStartButtonState();
        return;
      }

      // Format dates to match your API requirement
      const formattedFromDateTime = `${formatDate(fromDate)}${formatTime(
        fromTime
      )}`;
      const formattedToDateTime = `${formatDate(toDate)}${formatTime(
        toTime
      )}`;

      // Validate date range
      if (new Date(toDate) < new Date(fromDate)) {
        alert("'To Date' cannot be earlier than 'From Date'");
        fetching = false;
        updateStartButtonState();
        return;
      }

      return fetch(
        `${API}opr=getplaybacktest&sdate=${formattedFromDateTime}&edate=${formattedToDateTime}&did=${did}`
      )
        .then((response) => response.json())
        .then((data) => {
          if (Array.isArray(data)) {
            playbackData = data
              .map((item) => {
                const lng = parseFloat(item.langitude);
                const lat = parseFloat(item.latitude);
                const angle = parseFloat(item.angle);
                return !isNaN(lng) && !isNaN(lat) && !isNaN(angle)
                  ? {
                    coordinates: [lng, lat],
                    angle: angle,
                    deviceId: item.deviceId,
                    speed: item.speed,
                    gps: item.digital_2,
                    engine: item.digital_2,
                    date: item.DeviceDate,
                  }
                  : null;
              })
              .filter(Boolean);
            fetching = false;
            updateStartButtonState();
            console.log("Playback Data Loaded:", playbackData);
          } else {
            fetching = false;
            updateStartButtonState();
            console.error("Unexpected data format: response is not an array");
          }
        })
        .catch((error) => {
          fetching = false;
          updateStartButtonState();
          console.error("Error fetching playback data:", error);
        });
    }

    //right-side set pop-up
    function updateVehicleInfo(data, totalDistance) {
      // Update speed
      document.getElementById("speedDisplay").textContent = `${Math.round(
        data.speed
      )} km/h`;

      // Update date-time - format to show in single line
      const dateTime = data.date.split(".")[0];
      const [date, time] = dateTime.split(" ");
      document.getElementById(
        "dateTimeDisplay"
      ).textContent = `${date} ${time}`;

      // Update distance
      document.getElementById(
        "distanceDisplay"
      ).textContent = `${totalDistance.toFixed(2)} km`;
    }

    // Helper function to format date as YYYY-MM-DD
    function formatDate(dateString) {
      const date = new Date(dateString);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    // Update this function to show distance
    function createPopupContent(data, totalDistance) {
      const devicename = deviceData.find((d) => d.did == data.deviceId)?.name;
      return `
          <div style="border-bottom: 1px solid #eee; margin-bottom: 10px; padding-bottom: 5px;">
              <b>Vehicle:</b> ${devicename} 
          </div>
          <div>
              <b>Speed:</b> ${Math.round(data.speed)} km/h <br/>
              <b>GPS:</b> <span class="status-indicator ${data.gps === "true" ? "status-on" : "status-off"
        }">
                  ${data.gps === "true" ? "ON" : "OFF"}
              </span><br/>
              <b>Engine:</b> <span class="status-indicator ${data.engine === "true" ? "status-on" : "status-off"
        }">
                  ${data.engine === "true" ? "ON" : "OFF"}
              </span><br/>
              <b>Date-Time:</b> ${data.date.split(".")[0]} <br/>
              <b>Distance:</b> ${totalDistance.toFixed(2)} km
          </div>
        `;
    }

    // Show custom popup at the marker position
    function showPopup(content) {
      if (isPopupClosedManually) return; // Do not show if manually closed
      popupContent.innerHTML = content;
      popup.style.display = "block";
      updatePopupPosition(); // Ensure popup is positioned correctly initially
    }

    // Update popup position to keep it above the vehicle
    function updatePopupPosition() {
      if (vehicleMarker && popup.style.display === "block") {
        const coordinates = vehicleMarker.getLngLat();
        const mapPos = myMap.project(coordinates);

        // Increase the vertical offset to move popup higher above the marker
        popup.style.left = `${mapPos.x}px`;
        popup.style.top = `${mapPos.y + 80}px`; // Changed from -60 to -120 to move it higher
      }
    }
    // Listen for map movement to adjust the popup position
    myMap.on("move", updatePopupPosition);

    // Hide custom popup, set flag if closed manually
    function hidePopup(manuallyClosed = false) {
      popup.style.display = "none";
      if (manuallyClosed) isPopupClosedManually = true;
    }

    // Update polyline dynamically
    let polylineInitialized = false;
    let currentPolylineData = [];

    function updatePolyline() {
      if (!dynamicPlaybackData || dynamicPlaybackData.length < 2) return;

      try {
        // Calculate new polyline data
        let lineFeatures = [];
        let cumulativeDistance = 0;

        for (let i = 0; i < dynamicPlaybackData.length - 1; i++) {
          const currentPoint = dynamicPlaybackData[i];
          const nextPoint = dynamicPlaybackData[i + 1];

          const segmentDistance = calculateDistance(
            currentPoint.coordinates[1],
            currentPoint.coordinates[0],
            nextPoint.coordinates[1],
            nextPoint.coordinates[0]
          );
          cumulativeDistance += segmentDistance;

          const speed = parseFloat(currentPoint.speed);
          const isOverSpeed = speed > speedThreshold;

          lineFeatures.push({
            type: "Feature",
            properties: {
              isOverSpeed: isOverSpeed,
              date: currentPoint.date,
              distance: cumulativeDistance.toFixed(2),
              speed: speed.toFixed(1),
            },
            geometry: {
              type: "LineString",
              coordinates: [currentPoint.coordinates, nextPoint.coordinates],
            },
          });
        }

        // Check if data has actually changed
        if (
          JSON.stringify(currentPolylineData) === JSON.stringify(lineFeatures)
        ) {
          return; // No update needed
        }

        // Update current data reference
        currentPolylineData = lineFeatures;

        if (!polylineInitialized) {
          // First time initialization
          initializePolyline(lineFeatures);
        } else {
          // Just update the source data
          myMap.getSource(polylineId).setData({
            type: "FeatureCollection",
            features: lineFeatures,
          });
        }
      } catch (error) {
        console.error("Error updating polyline:", error);
      }
    }

    function initializePolyline(initialFeatures) {
      try {
        // Clean up any existing layers/sources
        if (myMap.getLayer(polylineId)) {
          myMap.removeLayer(polylineId);
        }
        if (myMap.getLayer(`${polylineId}-direction`)) {
          myMap.removeLayer(`${polylineId}-direction`);  
        }
        if (myMap.getSource(polylineId)) {
          myMap.removeSource(polylineId);
        }
        // Add source
        myMap.addSource(polylineId, {
          type: "geojson",
          data: {
            type: "FeatureCollection",
            features: initialFeatures,
          },
        });
        // Main polyline
        myMap.addLayer({
          id: polylineId,
          type: "line",
          source: polylineId,
          layout: {
            "line-join": "round",
            "line-cap": "round",
            visibility: "visible",
          },
          paint: {
            "line-color": [
              "case",
              ["get", "isOverSpeed"],
              "#FF0000",
              "#00FF00",
            ],
            "line-width": 4,
          },
        });
        // Direction arrows layer
        myMap.addLayer({
          id: `${polylineId}-direction`,
          type: "symbol",
          source: polylineId,
          layout: {
            "symbol-placement": "line",
            "text-field": "‚Üí",
            "text-size": 20,
            "text-pitch-alignment": "viewport",
            "symbol-spacing": 70,
            "text-keep-upright": false,
            "text-rotation-alignment": "map",
            "text-ignore-placement": true,
            "text-allow-overlap": true,
            "icon-rotation-alignment": "map"
          },
          paint: {
            "text-color": "#000000",
            "text-halo-color": "#FFFFFF",
            "text-halo-width": 2
          }
        });
        setupHoverInteractions();
        polylineInitialized = true;
      } catch (error) {
        console.error("Error initializing polyline:", error);
        polylineInitialized = false;
      }
    }

    
    function setupHoverInteractions() {
      const popup = document.getElementById("polylinePopup");
      const popupContent = document.getElementById("polylinePopupContent");

      // Remove existing listeners if any
      myMap.off("mousemove", polylineId);
      myMap.off("mouseleave", polylineId);

      // Mouse enter event
      myMap.on("mousemove", polylineId, (e) => {
        myMap.getCanvas().style.cursor = "pointer";

        if (e.features.length > 0) {
          const feature = e.features[0];
          popupContent.innerHTML = `
        <div style="font-weight: 500; margin-bottom: 4px">
          ${feature.properties.date}
        </div>
        <div>
          Distance: ${feature.properties.distance} km<br>
          Speed: ${feature.properties.speed} km/h
        </div>
      `;

          popup.style.display = "block";
          updatePolylinePopupPosition(e);
        }
      });

      // Mouse leave event
      myMap.on("mouseleave", polylineId, () => {
        myMap.getCanvas().style.cursor = "";
        popup.style.display = "none";
      });
    }

    // Function to clean up polyline
    function cleanupPolyline() {
      try {
        if (myMap.getLayer(polylineId)) {
          myMap.removeLayer(polylineId);
        }
        if (myMap.getSource(polylineId)) {
          myMap.removeSource(polylineId);
        }
        polylineInitialized = false;
        currentPolylineData = [];
      } catch (error) {
        console.error("Error cleaning up polyline:", error);
      }
    }
    // Add event listener for speed threshold changes
    document
      .getElementById("overSpeedingThreshold")
      .addEventListener("change", function () {
        speedThreshold = parseInt(this.value);
        // Redraw the entire route with new threshold
        updatePolyline();
      });

    // Function to calculate distance between two coordinates using Haversine formula (in kilometers)
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Radius of the Earth in km
      const dLat = (lat2 - lat1) * (Math.PI / 180);
      const dLon = (lon2 - lon1) * (Math.PI / 180);

      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * (Math.PI / 180)) *
        Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

      return R * c; // Distance in kilometers
    }

    // Add these variables at the top with your other variables
    let playbackSpeed = 1;
    const MIN_SPEED = 0.25;
    const MAX_SPEED = 8;
    const SPEED_STEP = 0.25;

    // Add these functions for speed control
    function updateSpeed(speed) {
      playbackSpeed = parseFloat(speed);
      document.getElementById("speedLabel").textContent = playbackSpeed + "x";

      // If playback is active, restart it with new speed
      if (playbackInterval && !isPaused) {
        clearInterval(playbackInterval);
        startPlayback(true); // Pass true to indicate it's a speed update
      }
    }

    function increaseSpeed() {
      if (playbackSpeed < MAX_SPEED) {
        playbackSpeed += SPEED_STEP;
        updateSliderAndSpeed();
      }
    }

    function decreaseSpeed() {
      if (playbackSpeed > MIN_SPEED) {
        playbackSpeed -= SPEED_STEP;
        updateSliderAndSpeed();
      }
    }

    function updateSliderAndSpeed() {
      document.getElementById("speedSlider").value = playbackSpeed;
      updateSpeed(playbackSpeed);
    }

    document.addEventListener("DOMContentLoaded", function () {
      setupDateValidation;
      updateStartButtonState(); // Set initial button state
    });

    // Playback control functions
    let startLat = null; // To store the starting position latitude
    let startLon = null; // To store the starting position longitude
    let totalDistance = 0; // To accumulate the distance

    // Modify your startPlayback function to account for speed
    //   function startPlayback(isSpeedUpdate = false) {

    //     cleanupPolylineEvents()

    //     if (fetching) {
    //     console.log("Data is still being fetched...");
    //     return;
    // }

    //     if (playbackData.length === 0) {
    //       console.error("Playback data is empty.");
    //       alert("Playback data is empty");
    //       return;
    //     }

    //     // Remove existing marker if not paused and not a speed update
    //     if (vehicleMarker && !isPaused && !isSpeedUpdate) {
    //       vehicleMarker.remove();
    //       vehicleMarker = null;
    //       dynamicPlaybackData = [];
    //       index = 0;
    //       totalDistance = 0;
    //     }

    //     // Create new marker if it doesn't exist
    //     if (!vehicleMarker) {
    //       const customMarker = document.createElement("div");
    //       customMarker.classList.add("customMarkerClass");

    //       const carImage = document.createElement("img");
    //       carImage.classList.add("carImage");
    //       carImage.src = "/images/truck1.png";
    //       customMarker.appendChild(carImage);

    //       vehicleMarker = olaMaps
    //         .addMarker({
    //           element: customMarker,
    //           offset: [0, -10],
    //           anchor: "center",
    //         })
    //         .setLngLat(playbackData[index].coordinates)
    //         .addTo(myMap);

    //       // Set the starting location marker (only once at the beginning)
    //       if (!startingMarker) {
    //         const startCoordinates = playbackData[0].coordinates; // Get the starting coordinates

    //         // Create the div element
    //         const markerElement = document.createElement("div");
    //         markerElement.innerHTML = "S"; // Add the "S" text

    //         startingMarker = olaMaps
    //           .addMarker({
    //             element: markerElement,
    //             offset: [0, -10],
    //             anchor: "center",
    //           })
    //           .setLngLat(startCoordinates)
    //           .addTo(myMap);

    //         // Style both the container and the text
    //         const element = startingMarker.getElement();
    //         element.style.backgroundColor = "green";
    //         element.style.width = "20px";
    //         element.style.height = "20px";
    //         element.style.borderRadius = "50%";
    //         element.style.border = "2px solid white"; // Made border thicker
    //         element.style.boxShadow = "0 0 3px rgba(0,0,0,0.3)"; // Added shadow for better visibility

    //         // Additional styles for the text
    //         element.style.color = "white";
    //         element.style.fontWeight = "bold";
    //         element.style.display = "flex";
    //         element.style.alignItems = "center";
    //         element.style.justifyContent = "center";
    //         element.style.fontSize = "12px";
    //       }

    //       vehicleMarker.getElement().addEventListener("click", () => {
    //         isPopupClosedManually = false;
    //         const content = createPopupContent(
    //           playbackData[index],
    //           totalDistance
    //         );
    //         showPopup(content, playbackData[index].coordinates);
    //       });

    //       startLat = playbackData[index].coordinates[1];
    //       startLon = playbackData[index].coordinates[0];
    //     }

    //     // Start playback interval with speed control
    //     isPaused = false;
    //     clearInterval(playbackInterval); // Clear any existing interval
    //     playbackInterval = setInterval(() => {
    //       if (index < playbackData.length) {
    //         const { coordinates, angle } = playbackData[index];
    //         vehicleMarker.setLngLat(coordinates);
    //         myMap.setCenter(coordinates);

    //         const markerElement = vehicleMarker
    //           .getElement()
    //           .querySelector("img");
    //         const adjustedAngle = angle + ANGLE_OFFSET;
    //         markerElement.style.transform = `rotate(${adjustedAngle}deg)`;

    //         dynamicPlaybackData.push(playbackData[index]);
    //         updatePolyline();
    //         let finaldist = 0;
    //         if (startLat !== null && startLon !== null) {
    //           const currentLat = coordinates[1];
    //           const currentLon = coordinates[0];
    //           totalDistance = calculateDistance(
    //             startLat,
    //             startLon,
    //             currentLat,
    //             currentLon
    //           );
    //           finaldist += totalDistance
    //         }

    //         const content = createPopupContent(
    //           playbackData[index],
    //           finaldist
    //         );
    //         showPopup(content);

    //         index++;
    //       } else {
    //         clearInterval(playbackInterval);
    //         hidePopup();
    //       }
    //     }, 1000 / playbackSpeed); // Adjust interval based on speed
    //   }


    // **Detect Stop During Playback** (this is the main change)
    function detectStopDuringPlayback(currentIndex) {
      if (currentIndex === 0) return; // Skip the first point, no previous point to compare

      const holdTime = parseInt(document.getElementById("holdTime").value); // Get hold time from dropdown
      const currentPoint = playbackData[currentIndex];
      const prevPoint = playbackData[currentIndex - 1];

      const prevTime = new Date(prevPoint.date);
      const currentTime = new Date(currentPoint.date);

      const timeDiff = (currentTime - prevTime) / (1000 * 60); // Time difference in minutes
      const distance = calculateDistance(
        prevPoint.coordinates[1],
        prevPoint.coordinates[0],
        currentPoint.coordinates[1],
        currentPoint.coordinates[0]
      );

      // Check if the vehicle has been stationary for the hold time and the distance is less than the threshold
      if (timeDiff >= holdTime && distance < MINIMUM_DISTANCE) {
        // Add stop marker dynamically
        const stopMarker = olaMaps
          .addMarker({
            element: createStopMarkerElement(timeDiff),
            offset: [0, -18], // Adjusted offset to position above the polyline
            anchor: "bottom", // Set anchor to bottom
          })
          .setLngLat(prevPoint.coordinates)
          .addTo(myMap);

        // Add marker to array for tracking
        stopMarkers.push(stopMarker);

        // **Set the event listener to show popup when stop marker is clicked**
        stopMarker.getElement().addEventListener("click", () => {
          showStopPopup(prevPoint, currentPoint, timeDiff);
        });

        console.log(
          `Stop dynamically set at ${prevPoint.coordinates[1]}, ${prevPoint.coordinates[0]}.\n` +
          `Stop Duration: ${timeDiff.toFixed(2)} minutes.\n` +
          `Stop Time: ${new Date(prevPoint.date).toLocaleString()} to ${new Date(currentPoint.date).toLocaleString()}`
        );
      }
    }

    // Helper to create the stop marker element
    function createStopMarkerElement(duration) {
      const stopElement = document.createElement("div");
      stopElement.classList.add('stop-marker');
      stopElement.style.position = "relative";
      stopElement.style.width = "30px"; // Made smaller for better proportion
      stopElement.style.height = "40px"; // Adjusted height for proper teardrop shape
      stopElement.style.display = "flex";
      stopElement.style.alignItems = "center";
      stopElement.style.justifyContent = "center";
      stopElement.style.zIndex = "10"; // Ensure it stays above the polyline
      stopElement.style.marginLeft = "18px"

      // Create main teardrop shape
      const marker = document.createElement("div");
      marker.style.position = "absolute";
      marker.style.width = "30px";
      marker.style.height = "30px"; // Make the circle part perfectly round
      marker.style.backgroundColor = "#ff0000"; // Pure red color
      marker.style.borderRadius = "50% 50% 50% 0"; // Modified border radius
      marker.style.transform = "rotate(-45deg)"; // Changed rotation
      marker.style.border = "1.5px solid white"; // Slightly thinner border
      marker.style.boxShadow = "0 2px 4px rgba(0,0,0,0.25)";
      marker.style.top = "0";

      // Container for text
      const textContainer = document.createElement("div");
      textContainer.style.position = "absolute";
      textContainer.style.width = "100%";
      textContainer.style.height = "100%";
      textContainer.style.display = "flex";
      textContainer.style.alignItems = "center";
      textContainer.style.justifyContent = "center";
      textContainer.style.transform = "rotate(45deg)"; // Counter-rotate to make text straight
      textContainer.style.color = "white";
      textContainer.style.fontSize = "8px"; // Slightly smaller text
      textContainer.style.fontWeight = "bold";
      textContainer.style.fontFamily = "Arial, sans-serif";
      textContainer.textContent = "STOP";

      marker.appendChild(textContainer);
      stopElement.appendChild(marker);

      return stopElement;
    }

    let popupMarker;

    // Function to show the popup when a stop marker is clicked
    function showStopPopup(startPoint, endPoint, duration) {
      const startTime = new Date(startPoint.date).toLocaleString();
      const endTime = new Date(endPoint.date).toLocaleString();
      const stopDuration = formatDuration(duration);
      const stopIndex = playbackData.findIndex(point =>
        point.coordinates[0] === startPoint.coordinates[0] &&
        point.coordinates[1] === startPoint.coordinates[1]
      );
      const cumulativeDistance = calculateCumulativeDistance(stopIndex);
      const coordinates = `${startPoint.coordinates[1]},${startPoint.coordinates[0]}`;

      const popup = document.getElementById("stopMarkerPopup");
      const popupContent = document.getElementById("stopPopupContent");

      // Function to update location text in the popup
      async function updateLocationText(coords) {
        const locationSpan = document.getElementById('locationText');
        const locationLink = document.getElementById('getLocationLink');

        // Disable link while fetching
        locationLink.style.pointerEvents = 'none';
        locationLink.style.opacity = '0.6';

        // Fetch and display location
        const location = await fetchLocation(coords);

        // Update UI with result
        if (locationSpan) {
          locationSpan.textContent = location;
          locationSpan.style.color = location.includes("Error") ? "#e74c3c" : "#2c3e50";
        }

        // Re-enable link
        locationLink.style.pointerEvents = 'auto';
        locationLink.style.opacity = '1';
      }

      popupContent.innerHTML = `
        <div style="font-family: Arial, sans-serif;">
            <b>Stop Duration:</b> 
            <span style="color: #e74c3c;">${stopDuration}</span>
            <br><br>
            
            <b>Stop Time:</b> 
            <span style="color: #3498db;">${startTime} - ${endTime}</span>
            <br><br>
            
            <b>Location:</b> 
            <a href="#" id="getLocationLink" 
               style="color: #2980b9; text-decoration: underline; cursor: pointer; display: inline-block;">
               Get Location
            </a>
            <span id="locationText" 
                  style="display: block; margin-top: 5px; color: #666; font-size: 13px;">
            </span>
            <br>
            
            <b>Distance Covered:</b> 
            <span style="color: #f39c12;">${cumulativeDistance.toFixed(2)} km</span>
            <br>
        </div>
    `;

      // Add click event listener to the Get Location link
      const locationLink = popup.querySelector('#getLocationLink');
      locationLink.addEventListener('click', (e) => {
        e.preventDefault();
        updateLocationText(coordinates);
      });

      // Create marker and show popup
      if (popupMarker) {
        popupMarker.remove();
      }

      popupMarker = olaMaps
        .addMarker({
          element: popup,
          offset: [0, -120],
          anchor: "bottom",
        })
        .setLngLat(startPoint.coordinates)
        .addTo(myMap);

      popup.style.display = "block";
    }

    function isValidCoordinates(lat, lng) {
      return !isNaN(lat) && !isNaN(lng) &&
        lat >= -90 && lat <= 90 &&
        lng >= -180 && lng <= 180;
    }

    // Function to fetch location from coordinates
    async function fetchLocation(latlng) {
      try {
        // Initial validation
        if (!latlng) {
          console.error("No coordinates provided");
          return "Location not available";
        }

        // Parse coordinates
        const [lat, lng] = latlng.split(",").map(coord => parseFloat(coord.trim()));

        // Validate coordinates
        if (!isValidCoordinates(lat, lng)) {
          console.error("Invalid coordinates:", lat, lng);
          return "Invalid coordinates";
        }

        // Get UI elements
        const locationSpan = document.getElementById('locationText');
        const locationLink = document.getElementById('getLocationLink');

        // Show loading state in UI
        if (locationSpan) {
          locationSpan.textContent = "Fetching location...";
          locationSpan.style.color = "#666";
        }

        // Make API call
        const response = await fetch(`${API}opr=getLoc&lat=${lat}&lang=${lng}`);

        // Check if response is ok
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Parse response
        const data = await response.json();

        // Validate response data
        if (!data || !Array.isArray(data) || data.length === 0) {
          console.error("Invalid response data:", data);
          return "Location not available";
        }

        // Get location
        const location = data[0].location || "Location not available";

        // Update UI
        if (locationSpan) {
          locationSpan.textContent = location;
          locationSpan.style.color = "#2c3e50";
        }

        // Hide the "Get Location" link after successful fetch
        if (locationLink && !location.includes("not available")) {
          locationLink.style.display = 'none';
        }

        return location;

      } catch (error) {
        console.error("Error fetching location:", error);
        const locationSpan = document.getElementById('locationText');
        const locationLink = document.getElementById('getLocationLink');

        if (locationSpan) {
          locationSpan.textContent = "Error fetching location";
          locationSpan.style.color = "#e74c3c";
        }

        // Keep link visible in case of error
        if (locationLink) {
          locationLink.style.display = 'inline-block';
          locationLink.style.pointerEvents = 'auto';
          locationLink.style.opacity = '1';
        }

        return "Error fetching location";
      }
    }


    // Helper function to calculate the duration in hours, minutes, and seconds
    function formatDuration(durationInMinutes) {
      const totalSeconds = Math.floor(durationInMinutes * 60);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      // Format as HH:MM:SS
      return `${hours}h ${minutes}m ${seconds}s`;
    }

    // Function to position the popup above the stop marker
    //     function updateStopPopupPosition(coordinates) {
    //     const mapPos = myMap.project(coordinates);
    //     const popup = document.getElementById("stopMarkerPopup");
    //     const popupHeight = popup.offsetHeight;

    //     // Position popup above the stop marker with a small gap
    //     popup.style.left = `${mapPos.x}px`;
    //     popup.style.top = `${mapPos.y - popupHeight - 10}px`; // 10px gap between marker and popup
    // }

    function hideStopPopup(manuallyClosed = false) {
      const popup = document.getElementById("stopMarkerPopup");
      popup.style.display = "none";
    }

    /*start time show starting point */
    function updateStartTimeDisplay(startDateTime) {
      const startTimeDisplay = document.getElementById("startTimeDisplay");
      if (startTimeDisplay) {
        // Remove milliseconds if present
        const formattedTime = startDateTime.split(".")[0];
        startTimeDisplay.textContent = formattedTime;
      }
    }

    function startPlayback(isSpeedUpdate = false) {

      const selectedVehicle = document.getElementById('selectedVehicle');
    if (selectedVehicle.textContent === 'Select Vehicle') {
        alert('Please select a vehicle before starting playback');
        return;
    }
      // Disable start button and enable pause/stop buttons
      document.getElementById("startPlayback").disabled = true;
      document.getElementById("pausePlayback").disabled = false;
      document.getElementById("stopPlayback").disabled = false;

      cleanupPolylineEvents();

      if (fetching) {
        console.log("Data is still being fetched...");
        return;
      }

      if (playbackData.length === 0) {
        console.error("Playback data is empty.");
        alert("Playback data is empty");
        return;
      }

      // Remove existing marker if not paused and not a speed update
      if (vehicleMarker && !isPaused && !isSpeedUpdate) {
        vehicleMarker.remove();
        vehicleMarker = null;
        dynamicPlaybackData = [];
        index = 0;
        totalDistance = 0;
      }

      // In your playback start function or where you initialize the playback:
      if (playbackData && playbackData.length > 0) {
        updateStartTimeDisplay(playbackData[0].date);
      }

      // Create new marker if it doesn't exist
      if (!vehicleMarker) {
        const customMarker = document.createElement("div");
        customMarker.classList.add("customMarkerClass");

        const markerContainer = document.createElement("div");
        markerContainer.style.position = "relative";
        markerContainer.style.display = "flex";
        markerContainer.style.flexDirection = "column";
        markerContainer.style.alignItems = "center";

        const carImage = document.createElement("img");
        carImage.classList.add("carImage");
        carImage.src = "/images/truck1.png";

        markerContainer.appendChild(carImage);
        customMarker.appendChild(markerContainer);

        vehicleMarker = olaMaps
          .addMarker({
            element: customMarker,
            offset: [0, -10],
            anchor: "center",
          })
          .setLngLat(playbackData[index].coordinates)
          .addTo(myMap);

        // Starting marker with its own time display
        if (!startingMarker) {
          const startCoordinates = playbackData[0].coordinates;
          const startDateTime = playbackData[0].date.split(".")[0];

          const startContainer = document.createElement("div");
          startContainer.style.position = "relative";
          startContainer.style.display = "flex";
          startContainer.style.flexDirection = "column";
          startContainer.style.alignItems = "center";

          const markerElement = document.createElement("div");
          markerElement.innerHTML = "S";
          markerElement.style.backgroundColor = "green";
          markerElement.style.width = "20px";
          markerElement.style.height = "20px";
          markerElement.style.borderRadius = "50%";
          markerElement.style.border = "2px solid white";
          markerElement.style.boxShadow = "0 0 3px rgba(0,0,0,0.3)";
          markerElement.style.color = "white";
          markerElement.style.fontWeight = "bold";
          markerElement.style.display = "flex";
          markerElement.style.alignItems = "center";
          markerElement.style.justifyContent = "center";
          markerElement.style.fontSize = "12px";

          const startTimeDisplay = document.createElement("div");
          startTimeDisplay.innerHTML = startDateTime;
          startTimeDisplay.style.backgroundColor = "white";
          startTimeDisplay.style.padding = "2px 6px";
          startTimeDisplay.style.borderRadius = "4px";
          startTimeDisplay.style.fontSize = "10px";
          startTimeDisplay.style.marginTop = "5px";
          startTimeDisplay.style.boxShadow = "0 1px 3px rgba(0,0,0,0.2)";
          startTimeDisplay.style.whiteSpace = "nowrap";
          startTimeDisplay.style.color = "#333";

          startContainer.appendChild(startTimeDisplay);
          startContainer.appendChild(markerElement);

          startingMarker = olaMaps
            .addMarker({
              element: startContainer,
              offset: [0, -10],
              anchor: "center",
            })
            .setLngLat(startCoordinates)
            .addTo(myMap);
        }

        vehicleMarker.getElement().addEventListener("click", () => {
          isPopupClosedManually = false;
          const cumulativeDistance = calculateCumulativeDistance(index);
          const content = createPopupContent(
            playbackData[index],
            cumulativeDistance
          );
          const content1 = updateVehicleInfo(
            playbackData[index],
            cumulativeDistance
          );
          showPopup(content, playbackData[index].coordinates);
        });
      }

      // Start playback interval with speed control
      isPaused = false;
      clearInterval(playbackInterval);
      playbackInterval = setInterval(() => {
        if (index < playbackData.length) {
          const currentPoint = playbackData[index];
          const { coordinates, angle, date } = currentPoint;

          // Update marker position and rotation
          vehicleMarker.setLngLat(coordinates);
          myMap.setCenter(coordinates);

          const markerElement = vehicleMarker
            .getElement()
            .querySelector("img");
          const adjustedAngle = angle + ANGLE_OFFSET;
          markerElement.style.transform = `rotate(${adjustedAngle}deg)`;

          // Add to polyline data
          dynamicPlaybackData.push(currentPoint);
          updatePolyline();

          // **Check if the car has stopped dynamically during playback**
          detectStopDuringPlayback(index);

          // Update vehicle information
          const cumulativeDistance = calculateCumulativeDistance(index);
          const content = createPopupContent(
            currentPoint,
            cumulativeDistance
          );
          updateVehicleInfo(currentPoint, cumulativeDistance);
          showPopup(content);

          index++;
        } else {
          clearInterval(playbackInterval);
          hidePopup();
        }
      }, 1000 / playbackSpeed);
    }

    // Add this helper function to calculate cumulative distance
    function calculateCumulativeDistance(currentIndex) {
      let cumulativeDistance = 0;

      for (let i = 0; i < currentIndex; i++) {
        const currentPoint = playbackData[i];
        const nextPoint = playbackData[i + 1];

        cumulativeDistance += calculateDistance(
          currentPoint.coordinates[1],
          currentPoint.coordinates[0],
          nextPoint.coordinates[1],
          nextPoint.coordinates[0]
        );
      }

      return cumulativeDistance;
    }

    let stopMarkers = [];

    function stopPlayback() {
      // Disable stop/pause buttons and enable start button
      document.getElementById("startPlayback").disabled = false;
      document.getElementById("pausePlayback").disabled = false;
      document.getElementById("stopPlayback").disabled = true;

      clearInterval(playbackInterval);
      playbackInterval = null;
      index = 0;
      isPaused = false;
      hidePopup();
      hideStopPopup();

      if (vehicleMarker) {
        vehicleMarker.remove(); // Remove the marker
        vehicleMarker = null; // Set to null for clean restart
      }

      // Remove starting marker
      if (startingMarker) {
        startingMarker.remove();
        startingMarker = null;
      }

      // Remove all stop markers
      stopMarkers.forEach(marker => {
        if (marker) marker.remove();
      });
      stopMarkers = [];

      // Clear the polyline
      dynamicPlaybackData = [];
      if (myMap.getSource(polylineId)) {
        myMap.getSource(polylineId).setData({
          type: "Feature",
          properties: {},
          geometry: {
            type: "LineString",
            coordinates: [],
          },
        });
      }

      // Reset map to initial position if there's data
      if (playbackData.length > 0) {
        myMap.setCenter(playbackData[0].coordinates);
      }

      // Clear all vehicle info displays using same format as updateVehicleInfo
      document.getElementById("speedDisplay").textContent = `${Math.round(
        0
      )} km/h`;
      document.getElementById("dateTimeDisplay").textContent = "--";
      document.getElementById("distanceDisplay").textContent = `${(0).toFixed(
        2
      )} km`;
    }

    // Add this when page loads to set initial state
    document.addEventListener('DOMContentLoaded', function () {
      // Initially disable pause and stop buttons
      document.getElementById("pausePlayback").disabled = false;
      document.getElementById("stopPlayback").disabled = true;
    });

    function pausePlayback() {
      if (playbackInterval) {
        // Disable pause button and enable start/stop buttons
        document.getElementById("startPlayback").disabled = false;
        document.getElementById("pausePlayback").disabled = true;
        document.getElementById("stopPlayback").disabled = false;

        clearInterval(playbackInterval);
        isPaused = true;
      }
    }

    // Function to update hover popup position
    function updatePolylinePopupPosition(e) {
      const popup = document.getElementById("polylinePopup");
      popup.style.left = `${e.point.x - 70}px`;
      popup.style.top = `${e.point.y + 20}px`; // Position above the cursor
    }

    function cleanupPolylineEvents() {
      if (myMap.getLayer(polylineId)) {
        myMap.off("mousemove", polylineId);
        myMap.off("mouseleave", polylineId);
      }
    }

    const originalStopPlayback = stopPlayback;
    stopPlayback = function () {
      cleanupPolylineEvents();
      originalStopPlayback();
    };

    // function stopPlayback() {
    //   clearInterval(playbackInterval);
    //   playbackInterval = null;
    //   index = 0;
    //   isPaused = false;
    //   hidePopup();

    //   if (vehicleMarker && playbackData.length > 0) {
    //     vehicleMarker.setLngLat(playbackData[0].coordinates);
    //     myMap.setCenter(playbackData[0].coordinates);
    //     const markerElement = vehicleMarker.getElement().querySelector("img");
    //     markerElement.style.transform = `rotate(${
    //       playbackData[0].angle + ANGLE_OFFSET
    //     }deg)`;
    //   }
    // }

    function setupDateValidation() {
    const fromDateInput = document.getElementById("fromDate");
    const toDateInput = document.getElementById("toDate");
    const fromTimeInput = document.getElementById("fromTime");
    const toTimeInput = document.getElementById("toTime");

    // Function to get current date in YYYY-MM-DD format
    function getCurrentDate() {
      const today = new Date();
      const year = today.getFullYear();
      const month = String(today.getMonth() + 1).padStart(2, '0');
      const day = String(today.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    // Set initial values when page loads
    const currentDate = getCurrentDate();
    
    // Set default values only if they haven't been set by URL parameters
    if (!fromDateInput.value) {
      fromDateInput.value = currentDate;
    }
    if (!toDateInput.value) {
      toDateInput.value = currentDate;
    }
    if (!fromTimeInput.value) {
      fromTimeInput.value = "00:00";
    }
    if (!toTimeInput.value) {
      toTimeInput.value = "23:59";
    }

    // Set max attribute to current date
    fromDateInput.max = currentDate;
    toDateInput.max = currentDate;

    function validateTimes() {
      if (fromDateInput.value === toDateInput.value) {
        const fromTime = fromTimeInput.value;
        const toTime = toTimeInput.value;

        if (fromTime > toTime) {
          alert("Start time cannot be after end time on the same day");
          toTimeInput.value = fromTime;
        }
      }
    }

    fromTimeInput.addEventListener("change", validateTimes);
    toTimeInput.addEventListener("change", validateTimes);

    // Validate From Date
    fromDateInput.addEventListener("input", function () {
      const fromDate = new Date(this.value);
      const toDate = new Date(toDateInput.value);
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      if (fromDate > today) {
        alert("From date cannot be in the future");
        this.value = currentDate;
        return;
      }

      if (toDateInput.value && fromDate > toDate) {
        alert("From date cannot be after To date");
        this.value = toDateInput.value;
        return;
      }

      toDateInput.min = this.value;
    });

    // Validate To Date
    toDateInput.addEventListener("input", function () {
      const fromDate = new Date(fromDateInput.value);
      const toDate = new Date(this.value);
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      if (toDate > today) {
        alert("To date cannot be in the future");
        this.value = currentDate;
        return;
      }

      if (fromDateInput.value && toDate < fromDate) {
        alert("To date cannot be before From date");
        this.value = fromDateInput.value;
        return;
      }

      fromDateInput.max = this.value;
    });
  }

  const dateTimeInputs = document.querySelectorAll('#fromDate, #toDate, #fromTime, #toTime');
dateTimeInputs.forEach(input => {
    input.addEventListener('change', () => {
        // Reset device selection
        document.getElementById('selectedVehicle').textContent = 'Select Vehicle';
        
        // Stop any ongoing playback
        stopPlayback();
        
        // Clear any existing data
        playbackData = [];
        dynamicPlaybackData = [];
        
        // Reset the dropdown display
        const dropdown = document.getElementById('deviceDropdown');
        if (dropdown) {
            dropdown.style.display = 'none';
        }
    });
});

    // Make sure to call setupDateValidation when the page loads
    document.addEventListener("DOMContentLoaded", function() {
      setupDateValidation();
    });
    
    document.addEventListener("DOMContentLoaded", function () {
      // Get URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const deviceName = urlParams.get("device");
      const fromDate = urlParams.get("from");
      const toDate = urlParams.get("to");
      const fromTime = urlParams.get("fromTime") || "00:00";
      const toTime = urlParams.get("toTime") || "23:59";

      const start = document.getElementById("startPlayback");
      if (deviceName && fromDate && toDate) {
        document.getElementById("fromDate").value = fromDate;
        document.getElementById("toDate").value = toDate;
        document.getElementById("fromTime").value = fromTime;
        document.getElementById("toTime").value = toTime;

        const dateInputs = document.querySelectorAll(".date-input input");
        if (dateInputs.length >= 2) {
          dateInputs[0].value = fromDate;
          dateInputs[1].value = toDate;
        }
        // Wait for the vehicle list to be populated
        const checkVehicleList = setInterval(() => {
          const vehicleList = document.getElementById("vehicleList");
          if (vehicleList && vehicleList.children.length > 0) {
            clearInterval(checkVehicleList);

            // Find and click the matching device in the list
            const deviceElements =
              vehicleList.querySelectorAll(".dropdown-item");
            for (const element of deviceElements) {
              if (element.textContent.trim() === deviceName) {
                element.click();
                break;
              }
            }
            // Click the start button after all the things are added
            fetchPlaybackData(deviceName).then(() => start.click());
          }
        }, 100);

        // Add a timeout to prevent infinite checking
        setTimeout(() => clearInterval(checkVehicleList), 10000);
      }
    });

    $(document).ready(function () {
      // Load navbar from external file
      $("#navbar-container").load("navbarola.html", function () {
        console.log("Navbar loaded successfully!");
      });

      // Check if 'mid' is available in localStorage otherwise ri-direct login page
      if (!localStorage.getItem("mid")) {
        // Redirect to login page if 'mid' is not found
        window.location.href = "/index.html";
      }

      setupDateValidation();
    });
    // Rest of the initialization code

    // Event listeners for playback controls
    $("#startPlayback").on("click", startPlayback);
    $("#pausePlayback").on("click", pausePlayback);
    $("#stopPlayback").on("click", stopPlayback);

    // Add speed control event listeners
    $("#speedSlider").on("input", function () {
      updateSpeed(this.value);
    });

    $("#increaseSpeed").on("click", increaseSpeed);
    $("#decreaseSpeed").on("click", decreaseSpeed);
  </script>
</body>

</html>