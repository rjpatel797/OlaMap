<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>GPS Playback System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- jQuery for API requests -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- Ola Maps SDK and custom styles -->
  <link href="/multi/drawableplaybackmultigoogle.css" rel="stylesheet">
</head>

<body>
  <div class="container">
    <!-- Navbar -->
    <div id="navbar-container"></div>
    <div class="content">
      <div class="controls">
        <div class="datetime-selector">
          <div class="device-selector">
            <div class="dropdown-container">
              <!-- Dropdown Button (Selected Vehicles) -->
              <div class="selected-vehicle" id="selectedVehicle" onclick="toggleDropdown()">
                Select Vehicles
              </div>

              <!-- Dropdown List (Hidden by default) -->
              <div class="dropdown-list" id="deviceDropdown">
                <!-- Search input for filtering vehicles -->
                <div class="dropdown-search">
                  <input type="text" placeholder="Search vehicles..." id="vehicleSearch"
                    onclick="event.stopPropagation()" onkeyup="filterVehicles(this.value)" />
                </div>

                <!-- List of filtered vehicles -->
                <div class="dropdown-items" id="vehicleList">
                  <!-- Vehicles will be populated here dynamically -->
                </div>
              </div>
            </div>
          </div>
          <div class="date-input">
            <label>From:</label>
            <div class="datetime-wrapper">
              <input type="date" id="fromDate" placeholder="dd/mm/yyyy" />
              <input type="time" id="fromTime" value="00:00" />
            </div>
          </div>
          <div class="date-input">
            <label>To:</label>
            <div class="datetime-wrapper">
              <input type="date" id="toDate" placeholder="dd/mm/yyyy" />
              <input type="time" id="toTime" value="23:59" />
            </div>
          </div>
        </div>

        <div class="buttonclass">
          <!-- <button id="startPlayback">Start</button>
          <button id="pausePlayback">Pause</button> -->
          <button id="stopPlayback">Reset</button>
        </div>
      </div>
      <div id="map"></div>
      <div id="polylinePopup" class="polyline-popup">
        <div id="polylinePopupContent"></div>
      </div>

      <!-- Custom Popup Element -->
      <div id="customPopup" class="popup">
        <span class="close-btn" onclick="hidePopup(true)">‚úñ</span>
        <div id="popupContent"></div>
      </div>
    </div>

    <!-- <div id="vehicleInfoPopup" class="vehicle-info-popup">
      <div class="info-container">
        <div class="info-card">
          <div class="info-icon">üöó</div>
          <div class="info-details">
            <span class="info-label">Speed</span>
            <span class="info-value" id="speedDisplay">0 km/h</span>
          </div>
        </div>
        
        <div class="info-card">
          <div class="info-icon">üïí</div>
          <div class="info-details">
            <span class="info-label">Time</span>
            <span class="info-value" id="dateTimeDisplay">--</span>
          </div>
        </div>
        
        <div class="info-card">
          <div class="info-icon">üìç</div>
          <div class="info-details">
            <span class="info-label">Distance</span>
            <span class="info-value" id="distanceDisplay">0 km</span>
          </div>
        </div>
      </div>
    </div> -->

  </div>

  <script src="../js/api.js"></script>
    <script>
      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_KEY}&callback=initMap&libraries=geometry`;
      script.async = true;
      script.defer = true;
      document.head.appendChild(script);
      </script>
  <script>
    let selectedDevices = [];
    let deviceDataMap = new Map(); // Store playback data for each device
    let deviceMarkers = new Map(); // Store markers for each device
    let devicePolylines = new Map(); // Store polylines for each device
    let bounds;
    let vehicleMarker = null;
    let playbackData = [];
    let index = 0;
    let playbackInterval = null;
    let isPaused = false;
    const polylineId = "dynamicPolyline";
    let isPopupClosedManually = false;
    let pathCoordinates = [];
    let startMarker = null;
    let endMarker = null;
    let startingMarker = null;
    let endingMarker = null;
    let totalDistance = 0;
    let map;

    const ANGLE_OFFSET = 90;
    const popup = document.getElementById("customPopup");
    const popupContent = document.getElementById("popupContent");

    $(document).ready(() => {
      $("#navbar-container").load("navbarola.html", () => {
        console.log("Navbar loaded.");
      });

      //   map.on("load", () => {
      //   console.log("Map loaded successfully");
      fetchDeviceData().catch((error) => {
        console.error("Error fetching device data:", error);
      });
      // });
    });

    // Initialize the Ola Maps SDK
    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 23.0225, lng: 72.5714 },
        zoom: 15,
        styles: [
          {
            featureType: "poi",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
          }
        ]
      });

      bounds = new google.maps.LatLngBounds();
    }

    const deviceColors = [
      '#FF0000', // Red
      '#00FF00', // Green
      '#0000FF', // Blue
      '#FFA500', // Orange
      '#800080', // Purple
      '#008080', // Teal
      '#FFD700', // Gold
      '#4B0082', // Indigo
      '#FF1493', // Deep Pink
      '#00CED1'  // Dark Turquoise
    ];




    function createCustomMarker(color, label) {
      const markerElement = document.createElement("div");
      markerElement.style.position = "block";

      // Create the marker circle
      const circle = document.createElement("div");
      circle.style.width = "24px";
      circle.style.height = "24px";
      circle.style.backgroundColor = color;
      circle.style.borderRadius = "50%";
      circle.style.border = "3px solid white";
      circle.style.boxShadow = "0 2px 4px rgba(0,0,0,0.3)";

      // Create label
      const labelDiv = document.createElement("div");
      labelDiv.style.position = "absolute";
      labelDiv.style.top = "50%";
      labelDiv.style.left = "50%";
      labelDiv.style.transform = "translate(-50%, -50%)";
      labelDiv.style.color = "white";
      labelDiv.style.fontSize = "12px";
      labelDiv.style.fontWeight = "bold";
      labelDiv.textContent = label;

      markerElement.appendChild(circle);
      markerElement.appendChild(labelDiv);

      return markerElement;
    }

    function addStartEndMarkers(coordinates) {
      // Remove existing markers if they exist
      if (startingMarker) startingMarker.remove();
      if (endingMarker) endingMarker.remove();

      if (!playbackData || playbackData.length < 2) return;

      const startPoint = playbackData[0];
      const endPoint = playbackData[playbackData.length - 1];

      // Create start marker with timestamp
      const startMarkerElement = createMarkerWithTimestamp(
        'S',
        startPoint.date.split('.')[0], // Remove milliseconds if present
        '#2ecc71' // Green color
      );

      startingMarker = olaMaps
        .addMarker({
          element: startMarkerElement,
          anchor: 'bottom',
        })
        .setLngLat(coordinates[0])
        .addTo(map);

      // Create end marker with timestamp
      const endMarkerElement = createMarkerWithTimestamp(
        'E',
        endPoint.date.split('.')[0], // Remove milliseconds if present
        '#e74c3c' // Red color
      );

      endingMarker = olaMaps
        .addMarker({
          element: endMarkerElement,
          anchor: 'bottom',
        })
        .setLngLat(coordinates[coordinates.length - 1])
        .addTo(map);
    }

    let devices = [];
    let selectedDeviceId = null;

    // Toggle the dropdown visibility
    function toggleDropdown() {
      const dropdown = document.getElementById("deviceDropdown");
      dropdown.style.display =
        dropdown.style.display === "block" ? "none" : "block";
    }

    // Filter vehicles based on the search input
    function filterVehicles(searchText) {
      const vehicleList = document.getElementById("vehicleList");
      const filteredDevices = devices.filter((device) =>
        device.name.toLowerCase().includes(searchText.toLowerCase())
      );

      populateVehicleList(filteredDevices);
    }

    // Select a vehicle and update the selected vehicle text
    function selectVehicle(deviceId, deviceName) {
      if (!deviceId) {
        console.error("No Vehicle ID provided");
        return;
      }

      selectedDeviceId = deviceId;
      document.getElementById("selectedVehicle").textContent = deviceName;
      document.getElementById("deviceDropdown").style.display = "none";

      // Get date values
      const fromDate = document.getElementById("fromDate").value;
      const toDate = document.getElementById("toDate").value;

      if (fromDate && toDate) {
        fetchPlaybackData(deviceId)
          .then(() => {
            if (playbackData.length) {
              addPolyline();
              addStartEndMarkers(pathCoordinates);
            }
          })
          .catch((error) => {
            console.error("Error fetching playback data:", error);
            alert("Error loading playback data. Please try again.");
          });
      } else {
        alert("Please select both From and To dates");
      }
    }

    // Populate the dropdown list with devices
    function populateVehicleList(devicesList) {
      const vehicleList = document.getElementById("vehicleList");
      vehicleList.innerHTML = "";

      if (!Array.isArray(devicesList) || devicesList.length === 0) {
        const noDevicesMsg = document.createElement("div");
        noDevicesMsg.className = "dropdown-item";
        noDevicesMsg.textContent = "No vehicles available";
        vehicleList.appendChild(noDevicesMsg);
        return;
      }

      devicesList.forEach((device) => {
        if (!device.did || !device.name) return;

        const item = document.createElement("div");
        item.className = "device-item";

        // Create color indicator
        const colorIndicator = document.createElement("div");
        colorIndicator.className = "color-indicator";

        // Find if device is selected
        const selectedDevice = selectedDevices.find(d => d.did === device.did);
        if (selectedDevice) {
          item.classList.add("selected");
          colorIndicator.style.backgroundColor = selectedDevice.color;
        }

        const nameSpan = document.createElement("span");
        nameSpan.textContent = device.name;

        item.appendChild(colorIndicator);
        item.appendChild(nameSpan);

        item.onclick = (e) => {
          e.stopPropagation();
          toggleDeviceSelection(device);
        };

        vehicleList.appendChild(item);
      });
    }

    function toggleDeviceSelection(device) {
      // Check if device is already selected
      const index = selectedDevices.findIndex(d => d.did === device.did);

      if (index === -1) {
        // Add device if not at maximum limit
        if (selectedDevices.length < deviceColors.length) {
          // Create device object with all necessary properties
          const newDevice = {
            did: device.did,
            name: device.name,
            color: deviceColors[selectedDevices.length]  // Use length for next available color
          };

          selectedDevices.push(newDevice);

          // Fetch data for the device
          fetchPlaybackData(newDevice.did)
            .then(data => {
              if (data && data.length > 0) {
                addPolyline(newDevice.did, newDevice.color);
              }
            })
            .catch(error => {
              console.error('Error fetching data:', error);
              const removeIdx = selectedDevices.findIndex(d => d.did === newDevice.did);
              if (removeIdx !== -1) {
                selectedDevices.splice(removeIdx, 1);
              }
              alert('Failed to load data for selected device');
            });
        } else {
          alert(`Maximum ${deviceColors.length} devices can be selected`);
          return;
        }
      } else {
        // Remove device
        const deviceId = selectedDevices[index].did;

        // Clean up device data and markers
        deviceDataMap.delete(deviceId);

        // Remove vehicle marker
        if (deviceMarkers.has(deviceId)) {
          deviceMarkers.get(deviceId).setMap(null); // Changed from remove()
          deviceMarkers.delete(deviceId);
        }

        // Remove start marker
        const startMarkerId = `start-${deviceId}`;
        if (deviceMarkers.has(startMarkerId)) {
          deviceMarkers.get(startMarkerId).setMap(null); // Changed from remove()
          deviceMarkers.delete(startMarkerId);
        }

        // Remove end marker
        const endMarkerId = `end-${deviceId}`;
        if (deviceMarkers.has(endMarkerId)) {
          deviceMarkers.get(endMarkerId).setMap(null); // Changed from remove()
          deviceMarkers.delete(endMarkerId);
        }

        // Remove polyline - Updated for Google Maps
        if (devicePolylines.has(deviceId)) {
          const polyline = devicePolylines.get(deviceId);
          // Remove event listeners to prevent memory leaks
          google.maps.event.clearListeners(polyline, 'mouseover');
          google.maps.event.clearListeners(polyline, 'mouseout');
          polyline.setMap(null);
          devicePolylines.delete(deviceId);
        }

        // Remove direction arrows
        const arrows = document.querySelectorAll(`.device-${deviceId}`);
        arrows.forEach(arrow => arrow.remove());
        const arrowsContainer = document.querySelector(`.direction-arrows-${deviceId}`);
        if (arrowsContainer) {
          arrowsContainer.remove();
        }

        // Remove device from selected devices array
        selectedDevices.splice(index, 1);

        // Reassign colors to remaining devices
        selectedDevices.forEach((device, idx) => {
          device.color = deviceColors[idx];
          // Redraw polyline and markers with new color if needed
          const deviceData = deviceDataMap.get(device.did);
          if (deviceData && deviceData.length > 0) {
            addPolyline(device.did, device.color);
          }
        });
      }

      // Update display
      updateSelectedVehiclesDisplay();
      populateVehicleList(devices);
    }


    function updateSelectedVehiclesDisplay() {
      const selectedVehicleElement = document.getElementById("selectedVehicle");
      if (selectedDevices.length === 0) {
        selectedVehicleElement.textContent = "Select Vehicles";
      } else {
        selectedVehicleElement.textContent = `${selectedDevices.length} Vehicle${selectedDevices.length > 1 ? 's' : ''} Selected`;
        const countSpan = document.createElement("span");
        countSpan.className = "selected-count";
        countSpan.textContent = selectedDevices.length;
        selectedVehicleElement.appendChild(countSpan);
      }
    }

    function fetchDeviceData() {
      const token = localStorage.getItem("token");
      if (!token) {
        console.error("No token found in localStorage");
        return;
      }

      return fetch(`${API}/api/devices/getDeviceListByMid`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then((data) => {
          if (!Array.isArray(data.data)) {
            throw new Error("Invalid data format received");
          }

          // Update the global devices array
          devices = data.data.map((item) => ({
            name: item.dname,
            did: item.did,
          }));

          // Populate the vehicle list with the fetched devices
          populateVehicleList(devices);
        })
        .catch((error) => {
          console.error("Error fetching Vehicle:", error);
          alert("Error loading vehicle list. Please try again.");
        });
    }

    // Close dropdown when clicking outside
    document.addEventListener("click", function (event) {
      const dropdown = document.getElementById("deviceDropdown");
      const selectedVehicle = document.getElementById("selectedVehicle");

      if (
        !event.target.closest(".device-selector") &&
        event.target !== selectedVehicle
      ) {
        dropdown.style.display = "none";
      }
    });

    function createDeviceList() {
      const deviceSelect = $("#deviceSelect");
      deviceSelect.empty().append('<option value="">Select Vehicle</option>');

      devices.forEach((device) => {
        const option = document.createElement("option");
        option.value = device.did;
        option.textContent = device.name;
        option.style.padding = "10px";
        deviceSelect.append(option);
      });

      deviceSelect.on("change", function () {
        const selectedDid = $(this).val();
        const selectedDevice = devices.find((d) => d.did == selectedDid);

        if (selectedDevice) {
          $("#deviceNameDisplay").text(selectedDevice.name);
          fetchPlaybackData(selectedDid);
        }
      });
    }

    // Validate coordinates before using them
    function isValidCoordinate(lng, lat) {
      return (
        !isNaN(lng) &&
        !isNaN(lat) &&
        lng >= -180 &&
        lng <= 180 &&
        lat >= -90 &&
        lat <= 90
      );
    }

    // Rest of your JavaScript functions (fetchPlaybackData, createPopupContent, etc.)
    // [Previous JavaScript code for playback controls and functionality remains the same]
    function formatTime(timeString) {
      return timeString + ':00';
    }
    // Function to fetch playback data from the API
    async function fetchPlaybackData(deviceId) {

      if (!deviceId) {
        console.error("No Vehicle ID provided");
        return Promise.reject("Vehicle ID required");
      }

      const fromDate = document.getElementById("fromDate").value;
      const toDate = document.getElementById("toDate").value;
      const fromTime = document.getElementById("fromTime").value;
      const toTime = document.getElementById("toTime").value;

      if (!fromDate || !toDate) {
        alert("Please select both From and To dates");
        return Promise.reject("Date selection required");
      }

      const formattedFromDateTime = `${formatDate(fromDate)} ${formatTime(fromTime)}`;
      const formattedToDateTime = `${formatDate(toDate)} ${formatTime(toTime)}`;

      try {
        const response = await fetch(
        `${API}/api/devices/playbackdata?sdate=${formattedFromDateTime}&edate=${formattedToDateTime}&did=${deviceId}`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      })
        const data = await response.json();

        if (!Array.isArray(data.data)) {
          throw new Error("Invalid data format received");
        }

        const processedData = data.data
          .map(item => {
            const lng = Number(item.langitude);
            const lat = Number(item.latitude);
            let angle = Number(item.angle) || 0;
            angle = ((angle % 360) + 360) % 360;

            if (!isValidCoordinate(lng, lat)) {
              return null;
            }

            return {
              coordinates: [lng, lat],
              angle: angle,
              deviceId: String(item.deviceId),
              speed: Number(item.speed) || 0,
              gps: item.digital_2,
              engine: item.digital_2,
              date: item.DeviceDate
            };
          })
          .filter(Boolean);

        deviceDataMap.set(deviceId, processedData);
        return processedData;
      } catch (error) {
        console.error("Error in fetchPlaybackData:", error);
        throw error;
      }
    }

    function rightSideVehicleInfo(data, totalDistance) {
      // Update speed
      document.getElementById("speedDisplay").textContent = `${Math.round(
        data.speed
      )} km/h`;

      // Update date-time - format to show in single line
      const dateTime = data.date.split(".")[0];
      const [date, time] = dateTime.split(" ");
      document.getElementById(
        "dateTimeDisplay"
      ).textContent = `${date} ${time}`;

      // Update distance
      document.getElementById(
        "distanceDisplay"
      ).textContent = `${totalDistance.toFixed(2)} km`;
    }

    function updateMapView() {
      if (pathCoordinates.length === 0) return;

      // Calculate bounds
      const lngs = pathCoordinates.map((coord) => coord[0]);
      const lats = pathCoordinates.map((coord) => coord[1]);

      const bounds = [
        [Math.min(...lngs) - 0.01, Math.min(...lats) - 0.01],
        [Math.max(...lngs) + 0.01, Math.max(...lats) + 0.01],
      ];

      // Safely update map bounds
      try {
        map.fitBounds(bounds, {
          padding: 50,
          duration: 1000,
        });
      } catch (error) {
        console.error("Error updating map bounds:", error);
      }
    }

    // Helper function to calculate bounds
    function calculateBounds(coordinates) {
      const lngs = coordinates.map((coord) => coord[0]);
      const lats = coordinates.map((coord) => coord[1]);

      return [
        [Math.min(...lngs) - 0.01, Math.min(...lats) - 0.01],
        [Math.max(...lngs) + 0.01, Math.max(...lats) + 0.01],
      ];
    }

    // Helper function to format date as YYYY-MM-DD

    function formatDate(dateString) {
      const date = new Date(dateString);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    // Function to add polyline
    function addPolyline(deviceId, color) {
      if (!deviceId) {
        console.error('Device ID is required for adding polyline');
        return;
      }

      const data = deviceDataMap.get(deviceId);
      if (!data || data.length === 0) return;

      // Clean up existing polylines and markers
      if (devicePolylines.has(deviceId)) {
        const existingPolyline = devicePolylines.get(deviceId);
        if (existingPolyline) {
          existingPolyline.setMap(null);
          google.maps.event.clearListeners(existingPolyline, 'mousemove');
          google.maps.event.clearListeners(existingPolyline, 'mouseout');
        }
        devicePolylines.delete(deviceId);
      }

      // Convert data points to path
      const path = data.map(item => ({
        lat: item.coordinates[1],
        lng: item.coordinates[0]
      }));

      // Create the polyline
      const polyline = new google.maps.Polyline({
        path: path,
        geodesic: true,
        strokeColor: color,
        strokeOpacity: 1.0,
        strokeWeight: 3,
        icons: [{
          icon: {
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            scale: 3,
            fillColor: color,
            fillOpacity: 1,
            strokeWeight: 2,
            strokeColor: "#ffff"
          },
          repeat: '100px'
        }]
      });

      // Add the polyline to the map
      polyline.setMap(map);
      devicePolylines.set(deviceId, polyline);

      // Create a custom popup element if it doesn't exist
      let hoverPopup = document.getElementById('polyline-hover-popup');
      if (!hoverPopup) {
        hoverPopup = document.createElement('div');
        hoverPopup.id = 'polyline-hover-popup';
        hoverPopup.className = 'polyline-popup';
        document.body.appendChild(hoverPopup);
      }

      // Add event listener to the map div to track mouse movement
      const mapDiv = map.getDiv();

      // Add hover effects with dynamic point information
      google.maps.event.addListener(polyline, 'mousemove', function (event) {
        if (!event.latLng) return;

        // Find the closest point to the mouse position
        const closestPoint = findClosestPointOnPolyline(event.latLng, data);

        if (closestPoint) {
          const popupContent = createPointInfoContent(closestPoint, deviceId);
          hoverPopup.innerHTML = popupContent;

          // Position the popup above the cursor
          const mapRect = mapDiv.getBoundingClientRect();

          hoverPopup.style.display = 'block';
          hoverPopup.style.position = 'fixed';
          hoverPopup.style.left = `${event.domEvent.clientX}px`;
          hoverPopup.style.top = `${event.domEvent.clientY - hoverPopup.offsetHeight - 10}px`; // Move above cursor
          hoverPopup.style.transform = 'translate(-50%, 0)';
        }
      });

      google.maps.event.addListener(polyline, 'mouseout', function () {
        const hoverPopup = document.getElementById('polyline-hover-popup');
        if (hoverPopup) {
          hoverPopup.style.display = 'none';
        }
      });

      // Add start/end markers for the device
      addStartEndMarkersForDevice(deviceId, path, color, data);
    }

    function findClosestPointOnPolyline(latLng, data) {
      let minDistance = Infinity;
      let closestPoint = null;

      for (let i = 0; i < data.length; i++) {
        const point = new google.maps.LatLng(
          data[i].coordinates[1],
          data[i].coordinates[0]
        );

        const distance = google.maps.geometry.spherical.computeDistanceBetween(latLng, point);

        if (distance < minDistance) {
          minDistance = distance;
          closestPoint = data[i];
        }
      }

      return closestPoint;
    }

    // Helper function to create detailed point information
    function createPointInfoContent(point, deviceId) {
      // Calculate distance from the start
      const totalDistance = calculateCumulativeDistance(point, deviceId);

      // Find the device name from selectedDevices array
      const selectedDevice = selectedDevices.find(d => d.did === deviceId);
      const deviceName = selectedDevice ? selectedDevice.name : deviceId;

      return `
        <div class="point-details">
            <div class="point-header">${deviceName}</div>
            <div class="point-info">
                <div><strong>Time:</strong> ${point.date.split('.')[0]}</div>
                <div><strong>Speed:</strong> ${point.speed.toFixed(1)} km/h</div>
                <div><strong>Distance:</strong> ${totalDistance.toFixed(2)} km</div>
            </div>
        </div>
    `;
    }

    function showPolylineInfo(latLng, deviceId, data) {
      const popup = document.getElementById('polylinePopup');
      const content = document.getElementById('polylinePopupContent');

      if (!popup || !content) return;

      // Find the selected device details
      const selectedDevice = selectedDevices.find(d => d.did === deviceId);
      if (!selectedDevice) return;

      // Calculate total distance
      let totalDistance = 0;
      for (let i = 1; i < data.length; i++) {
        const prev = data[i - 1];
        const curr = data[i];
        totalDistance += calculateDistance(
          prev.coordinates[1],
          prev.coordinates[0],
          curr.coordinates[1],
          curr.coordinates[0]
        );
      }

      // Create content for the popup
      const contentHTML = `
        <div style="font-size: 12px; line-height: 1.5;">
            <div style="font-weight: bold; margin-bottom: 4px;">${selectedDevice.name}</div>
            <div>Total Distance: ${totalDistance.toFixed(2)} km</div>
            <div>Start Time: ${data[0].date.split('.')[0]}</div>
            <div>End Time: ${data[data.length - 1].date.split('.')[0]}</div>
        </div>
    `;

      content.innerHTML = contentHTML;

      // Position the popup at the mouse location
      const point = map.getProjection().fromLatLngToPoint(latLng);
      const mapContainer = document.getElementById('map');
      const mapRect = mapContainer.getBoundingClientRect();

      popup.style.display = 'block';
      popup.style.left = `${point.x - mapRect.left}px`;
      popup.style.top = `${point.y - mapRect.top - popup.offsetHeight - 10}px`;

      // Add mousemove event listener to update popup position
      map.getDiv().addEventListener('mousemove', updatePolylinePopupPosition);
    }

    function hidePolylineInfo() {
      const popup = document.getElementById('polylinePopup');
      if (popup) {
        popup.style.display = 'none';
      }
      // Remove mousemove event listener
      map.getDiv().removeEventListener('mousemove', updatePolylinePopupPosition);
    }

    function updatePolylinePopupPosition(e) {
      const popup = document.getElementById('polylinePopup');
      if (popup && popup.style.display === 'block') {
        const mapContainer = document.getElementById('map');
        const mapRect = mapContainer.getBoundingClientRect();
        const x = e.clientX - mapRect.left;
        const y = e.clientY - mapRect.top;

        popup.style.left = `${x}px`;
        popup.style.top = `${y - popup.offsetHeight - 10}px`;
      }
    }

    function createMarkerWithTimestamp(label, timestamp, color) {
      const div = document.createElement('div');
      div.innerHTML = `
        <div style="
            position: relative;
            text-align: center;
        ">
            <div style="
                background-color: ${color};
                color: white;
                padding: 5px;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
            ">
                ${label}
            </div>
            <div style="
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                white-space: nowrap;
                font-size: 12px;
                margin-top: 4px;
            ">
                ${timestamp}
            </div>
        </div>`;
      return div;
    }

    function addStartEndMarkersForDevice(deviceId, path, color, data) {
      const startMarkerId = `start-${deviceId}`;
      const endMarkerId = `end-${deviceId}`;

      // Clean up existing markers
      if (deviceMarkers.has(startMarkerId)) {
        deviceMarkers.get(startMarkerId).setMap(null);
        deviceMarkers.delete(startMarkerId);
      }
      if (deviceMarkers.has(endMarkerId)) {
        deviceMarkers.get(endMarkerId).setMap(null);
        deviceMarkers.delete(endMarkerId);
      }

      if (!data || data.length < 2) return;

      try {
        // Add start marker
        const startPoint = data[0];
        const startMarker = new google.maps.Marker({
          position: {
            lat: path[0].lat,
            lng: path[0].lng
          },
          map: map,
          title: 'Start',
          label: {
            text: 'S',
            color: 'white',
            fontSize: '12px',
            fontWeight: 'bold'
          },
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: color,
            fillOpacity: 1,
            strokeColor: '#FFFFFF',
            strokeWeight: 2,
            scale: 12,
            labelOrigin: new google.maps.Point(0, 0)
          },
          zIndex: 1
        });

        // Create InfoWindow for start marker
        const startInfo = new google.maps.InfoWindow({
          content: startPoint.date.split('.')[0],
          pixelOffset: new google.maps.Size(0, -30)
        });
        startInfo.open(map, startMarker);

        deviceMarkers.set(startMarkerId, startMarker);

        // Add end marker
        const endPoint = data[data.length - 1];
        const endMarker = new google.maps.Marker({
          position: {
            lat: path[path.length - 1].lat,
            lng: path[path.length - 1].lng
          },
          map: map,
          title: 'End',
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: color,
            fillOpacity: 1,
            strokeColor: '#FFFFFF',
            strokeWeight: 2,
            scale: 12,
            labelOrigin: new google.maps.Point(0, 0)
          },
          label: {
            text: 'E',
            color: '#FFFFFF',
            fontSize: '12px',
            fontWeight: 'bold',
          },
          zIndex: 1
        });

        // Create InfoWindow for end marker
        const endInfo = new google.maps.InfoWindow({
          content: endPoint.date.split('.')[0],
          pixelOffset: new google.maps.Size(0, -30)
        });
        endInfo.open(map, endMarker);

        deviceMarkers.set(endMarkerId, endMarker);

        // Add hover effect for markers
        [startMarker, endMarker].forEach(marker => {
          marker.addListener('mouseover', function () {
            this.setIcon({
              ...this.getIcon(),
              scale: 14 // Slightly larger on hover
            });
          });

          marker.addListener('mouseout', function () {
            this.setIcon({
              ...this.getIcon(),
              scale: 12 // Back to normal size
            });
          });
        });

      } catch (error) {
        console.error(`Error adding markers for device ${deviceId}:`, error);
      }
    }


    function updateMapBounds() {
      let allCoordinates = [];
      deviceDataMap.forEach(data => {
        allCoordinates = allCoordinates.concat(data.map(item => item.coordinates));
      });

      if (allCoordinates.length > 0) {
        const bounds = allCoordinates.reduce(
          (bounds, coord) => {
            return [
              [Math.min(bounds[0][0], coord[0]), Math.min(bounds[0][1], coord[1])],
              [Math.max(bounds[1][0], coord[0]), Math.max(bounds[1][1], coord[1])]
            ];
          },
          [[allCoordinates[0][0], allCoordinates[0][1]], [allCoordinates[0][0], allCoordinates[0][1]]]
        );

        map.fitBounds(bounds, {
          padding: 50,
          duration: 1000
        });
      }
    }

    function cleanupPolylineEvents() {
      if (map.getLayer(polylineId)) {
        map.off('mousemove', polylineId);
        map.off('mouseleave', polylineId);
      }
    }

    let endpointMarker = null; // Global variable to store the endpoint marker

    function addEndpointMarker(coordinate) {
      if (endpointMarker) endpointMarker.remove();

      const markerElement = document.createElement("div");
      markerElement.style.width = "24px";
      markerElement.style.height = "24px";
      markerElement.style.backgroundColor = "red";
      markerElement.style.borderRadius = "50%";

      endpointMarker = olaMaps
        .addMarker({
          element: markerElement,
          anchor: "center",
        })
        .setLngLat(coordinate)
        .addTo(map);

    }

    function updateMarkerRotation(angle) {
      if (vehicleMarker) {
        const markerElement = vehicleMarker.getElement();
        const imageElement = markerElement.querySelector(".carImage");

        if (imageElement) {
          const rotationAngle = (angle + ANGLE_OFFSET) % 360;
          // Apply rotation while maintaining centering
          imageElement.style.transform = `translate(-50%, -50%) rotate(${rotationAngle}deg)`;
        }
      }
    }

    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * (Math.PI / 180);
      const dLon = (lon2 - lon1) * (Math.PI / 180);

      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function calculateCumulativeDistance(targetPoint, deviceId) {
      const data = deviceDataMap.get(deviceId);
      if (!data) return 0;

      let totalDistance = 0;
      for (let i = 1; i < data.length; i++) {
        const prevPoint = data[i - 1];
        const currentPoint = data[i];

        // Calculate and add distance between points
        const distance = calculateDistance(
          prevPoint.coordinates[1],
          prevPoint.coordinates[0],
          currentPoint.coordinates[1],
          currentPoint.coordinates[0]
        );
        totalDistance += distance;

        // Stop when we reach the target point
        if (currentPoint === targetPoint) {
          break;
        }
      }

      return totalDistance;
    }

    function startPlayback() {
      if (selectedDevices.length === 0) {
        alert('Please select at least one vehicle');
        return;
      }

      if (playbackInterval) {
        clearInterval(playbackInterval);
      }

      // Reset indexes for all devices if not paused
      if (!isPaused) {
        selectedDevices.forEach(device => {
          device.index = 0;
          device.totalDistance = 0;
        });
      }

      isPaused = false;

      // Create markers for each device if they don't exist
      selectedDevices.forEach(device => {
        if (!deviceMarkers.has(device.did)) {
          const carMarkerElement = createVehicleMarker(device.color);
          const marker = olaMaps.addMarker({
            element: carMarkerElement,
            anchor: 'center'
          });
          deviceMarkers.set(device.did, marker);
        }
      });

      playbackInterval = setInterval(() => {
        let allComplete = true;

        selectedDevices.forEach(device => {
          const data = deviceDataMap.get(device.did);
          if (!data) return;

          if (device.index < data.length) {
            allComplete = false;
            const point = data[device.index];

            const marker = deviceMarkers.get(device.did);
            if (marker) {
              marker.setLngLat(point.coordinates);
              updateMarkerRotation(marker, point.angle);
            }

            // Update device info
            if (device.index > 0) {
              const prevPoint = data[device.index - 1];
              device.totalDistance += calculateDistance(
                prevPoint.coordinates[1],
                prevPoint.coordinates[0],
                point.coordinates[1],
                point.coordinates[0]
              );
            }

            device.index++;
          }
        });

        if (allComplete) {
          clearInterval(playbackInterval);
          playbackInterval = null;
        }
      }, 1000);
    }

    function createVehicleMarker(color) {
      const markerElement = document.createElement("div");
      markerElement.classList.add("customMarkerClass");

      const carImage = document.createElement("img");
      carImage.src = "images/truck1.png";
      carImage.alt = "Vehicle Marker";
      carImage.classList.add("carImage");
      carImage.style.filter = `hue-rotate(${getHueRotation(color)}deg)`;

      markerElement.appendChild(carImage);
      return markerElement;
    }

    function getHueRotation(color) {
      // Convert hex color to hue rotation degree
      // This is a simplified version - you might want to implement a more accurate conversion
      const colors = {
        '#FF0000': 0,    // Red
        '#00FF00': 120,  // Green
        '#0000FF': 240,  // Blue
        '#FFA500': 39,   // Orange
        '#800080': 300,  // Purple
        '#008080': 180,  // Teal
        '#FFD700': 51,   // Gold
        '#4B0082': 275,  // Indigo
        '#FF1493': 328,  // Deep Pink
        '#00CED1': 181   // Dark Turquoise
      };
      return colors[color] || 0;
    }

    // Store event listeners for each device
    const deviceEventListeners = new Map();

    function removeDirectionArrowsForDevice(deviceId) {
      // Remove the event listener from the map if it exists
      if (deviceEventListeners.has(deviceId)) {
        const listener = deviceEventListeners.get(deviceId);
        map.off('move', listener);
        deviceEventListeners.delete(deviceId);
      }

      // Remove all arrows with this device's class
      const existingArrows = document.querySelectorAll(`.device-${deviceId}`);
      existingArrows.forEach(arrow => arrow.remove());

      // Remove the container for this device
      const arrowContainer = document.querySelector(`.direction-arrows-${deviceId}`);
      if (arrowContainer) {
        arrowContainer.remove();
      }
    }

    function cleanupAllArrows() {
      // Remove all event listeners
      deviceEventListeners.forEach((listener, deviceId) => {
        map.off('move', listener);
      });
      deviceEventListeners.clear();

      // Remove all arrow elements
      const allArrows = document.querySelectorAll('[class*="direction-arrow"]');
      allArrows.forEach(arrow => arrow.remove());

      // Remove all arrow containers
      const allContainers = document.querySelectorAll('[class*="direction-arrows-"]');
      allContainers.forEach(container => container.remove());
    }

    function stopPlayback() {
      // Clear the playback interval
      clearInterval(playbackInterval);
      playbackInterval = null;
      isPaused = false;

      // Clean up all arrows
      cleanupAllArrows();

      // Clear all vehicle markers
      deviceMarkers.forEach(marker => {
        marker.setMap(null);  // Changed from remove()
        google.maps.event.clearInstanceListeners(marker); // Clean up any event listeners
      });
      deviceMarkers.clear();

      // Remove all polylines and their events
      devicePolylines.forEach((polyline, deviceId) => {
        // Remove the polyline from the map
        if (polyline) {
          google.maps.event.clearListeners(polyline, 'mouseover');
          google.maps.event.clearListeners(polyline, 'mouseout');
          polyline.setMap(null);
        }

        // Remove start/end markers for this device
        const startMarkerId = `start-${deviceId}`;
        const endMarkerId = `end-${deviceId}`;

        if (deviceMarkers.has(startMarkerId)) {
          const startMarker = deviceMarkers.get(startMarkerId);
          startMarker.setMap(null);
          google.maps.event.clearInstanceListeners(startMarker);
          deviceMarkers.delete(startMarkerId);
        }

        if (deviceMarkers.has(endMarkerId)) {
          const endMarker = deviceMarkers.get(endMarkerId);
          endMarker.setMap(null);
          google.maps.event.clearInstanceListeners(endMarker);
          deviceMarkers.delete(endMarkerId);
        }
      });

      // Clear collection data
      deviceDataMap.clear();
      devicePolylines.clear();

      // Reset selected devices array
      selectedDevices = [];

      // Reset the vehicle selection display
      const selectedVehicleElement = document.getElementById("selectedVehicle");
      if (selectedVehicleElement) {
        selectedVehicleElement.textContent = "Select Vehicles";
      }

      // Clear the dropdown selection
      const vehicleList = document.getElementById("vehicleList");
      if (vehicleList) {
        const items = vehicleList.querySelectorAll('.device-item');
        items.forEach(item => item.classList.remove('selected'));
      }

      // Hide polyline popup
      const polylinePopup = document.getElementById('polylinePopup');
      if (polylinePopup) {
        polylinePopup.style.display = 'none';
      }

      // Hide and reset vehicle info popup
      const vehicleInfoPopup = document.getElementById('vehicleInfoPopup');
      if (vehicleInfoPopup) {
        vehicleInfoPopup.style.display = 'none';
        if (document.getElementById('speedDisplay')) {
          document.getElementById('speedDisplay').textContent = '0 km/h';
        }
        if (document.getElementById('dateTimeDisplay')) {
          document.getElementById('dateTimeDisplay').textContent = '--';
        }
        if (document.getElementById('distanceDisplay')) {
          document.getElementById('distanceDisplay').textContent = '0 km';
        }
      }

      // Clean up any remaining map event listeners
      if (map) {
        google.maps.event.clearListeners(map, 'mousemove');
      }

      // Redraw the vehicle list
      populateVehicleList(devices);
    }

    // Helper function to clean up all direction arrows
    function cleanupAllArrows() {
      // Remove all event listeners
      deviceEventListeners.forEach((listener, deviceId) => {
        if (map) {
          google.maps.event.removeListener(listener);
        }
      });
      deviceEventListeners.clear();

      // Remove all arrow elements
      const allArrows = document.querySelectorAll('[class*="direction-arrow"]');
      allArrows.forEach(arrow => arrow.remove());

      // Remove all arrow containers
      const allContainers = document.querySelectorAll('[class*="direction-arrows-"]');
      allContainers.forEach(container => container.remove());
    }

    function pausePlayback() {
      if (playbackInterval) {
        clearInterval(playbackInterval);
        playbackInterval = null;
        isPaused = true;
      }
    }

    // Add this function to your JavaScript code
    function calculateDistance(lat1, lon1, lat2, lon2) {
      // Convert degrees to radians
      const toRad = deg => deg * (Math.PI / 180);

      // Radius of the Earth in km
      const R = 6371;

      // Convert coordinates to radians
      const lat1Rad = toRad(lat1);
      const lon1Rad = toRad(lon1);
      const lat2Rad = toRad(lat2);
      const lon2Rad = toRad(lon2);

      // Calculate differences
      const dLat = lat2Rad - lat1Rad;
      const dLon = lon2Rad - lon1Rad;

      // Haversine formula
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1Rad) * Math.cos(lat2Rad) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

      // Calculate distance
      return R * c; // Returns distance in kilometers
    }

    function createPopupContent(data, totalDistance = 0) {
      return `
          <div style="border-bottom: 1px solid #eee; margin-bottom: 10px; padding-bottom: 5px;">
              <b>Vehicle:</b> ${data.deviceId} 
          </div>
          <div>
              <b>Speed:</b> ${Math.round(data.speed)} km/h <br/>
              <b>GPS:</b> <span class="status-indicator ${data.gps === "true" ? "status-on" : "status-off"}">
                  ${data.gps === "true" ? "ON" : "OFF"}
              </span><br/>
              <b>Engine:</b> <span class="status-indicator ${data.engine === "true" ? "status-on" : "status-off"}">
                  ${data.engine === "true" ? "ON" : "OFF"}
              </span><br/>
              <b>Date-Time:</b> ${data.date.split(".")[0]} <br/>
              <b>Distance:</b> ${totalDistance.toFixed(2)} km
          </div>`;
    }

    // Show custom popup at the marker position
    function showPopup(content) {
      if (isPopupClosedManually) return; // Do not show if manually closed
      popupContent.innerHTML = content;
      popup.style.display = "block";
      updatePopupPosition(); // Ensure popup is positioned correctly initially
    }

    // Update popup position to keep it above the vehicle
    function updatePopupPosition() {
      if (vehicleMarker && popup.style.display === "block") {
        const coordinates = vehicleMarker.getLngLat();
        const mapPos = map.project(coordinates);

        // Increase the vertical offset to move popup higher above the marker
        popup.style.left = `${mapPos.x}px`;
        popup.style.top = `${mapPos.y + 80}px`; // Changed from -60 to -120 to move it higher
      }
    }
    // Listen for map movement to adjust the popup position
    //     map.on('move', () => {
    //   updatePopupPosition();
    //   addDirectionArrows();
    // });

    // Hide custom popup, set flag if closed manually
    function hidePopup(manuallyClosed = false) {
      popup.style.display = "none";
      if (manuallyClosed) {
        isPopupClosedManually = true;
        // Add a small delay before allowing the popup to be shown again
        // setTimeout(() => {
        //     isPopupClosedManually = false;
        // }, 200); // 200ms delay to prevent immediate re-opening
      }
    }

    function setupDateValidation() {
      const fromDateInput = document.getElementById("fromDate");
      const toDateInput = document.getElementById("toDate");
      const fromTimeInput = document.getElementById("fromTime");
      const toTimeInput = document.getElementById("toTime");

      // Function to get current date in YYYY-MM-DD format
      function getCurrentDate() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      // Set initial values when page loads
      const currentDate = getCurrentDate();

      // Set default values only if they haven't been set by URL parameters
      if (!fromDateInput.value) {
        fromDateInput.value = currentDate;
      }
      if (!toDateInput.value) {
        toDateInput.value = currentDate;
      }
      if (!fromTimeInput.value) {
        fromTimeInput.value = "00:00";
      }
      if (!toTimeInput.value) {
        toTimeInput.value = "23:59";
      }

      // Set max attribute to current date
      fromDateInput.max = currentDate;
      toDateInput.max = currentDate;

      function validateTimes() {
        if (fromDateInput.value === toDateInput.value) {
          const fromTime = fromTimeInput.value;
          const toTime = toTimeInput.value;

          if (fromTime > toTime) {
            alert("Start time cannot be after end time on the same day");
            toTimeInput.value = fromTime;
          }
        }
      }

      fromTimeInput.addEventListener("change", validateTimes);
      toTimeInput.addEventListener("change", validateTimes);

      // Validate From Date
      fromDateInput.addEventListener("input", function () {
        const fromDate = new Date(this.value);
        const toDate = new Date(toDateInput.value);
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        if (fromDate > today) {
          alert("From date cannot be in the future");
          this.value = currentDate;
          return;
        }

        if (toDateInput.value && fromDate > toDate) {
          alert("From date cannot be after To date");
          this.value = toDateInput.value;
          return;
        }

        toDateInput.min = this.value;
      });

      // Validate To Date
      toDateInput.addEventListener("input", function () {
        const fromDate = new Date(fromDateInput.value);
        const toDate = new Date(this.value);
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        if (toDate > today) {
          alert("To date cannot be in the future");
          this.value = currentDate;
          return;
        }

        if (fromDateInput.value && toDate < fromDate) {
          alert("To date cannot be before From date");
          this.value = fromDateInput.value;
          return;
        }

        fromDateInput.max = this.value;
      });
    }

    // Make sure to call setupDateValidation when the page loads
    document.addEventListener("DOMContentLoaded", function () {
      setupDateValidation();
    });


    function addDirectionArrows() {
      // Remove existing arrows if any
      const existingArrows = document.querySelectorAll('.direction-arrow');
      existingArrows.forEach(arrow => arrow.remove());

      // Calculate total path length and number of arrows needed
      const ARROW_SPACING = 150; // pixels between arrows
      let totalLength = 0;
      const segments = [];

      // Calculate segments and their lengths
      for (let i = 0; i < pathCoordinates.length - 1; i++) {
        const start = map.project(pathCoordinates[i]);
        const end = map.project(pathCoordinates[i + 1]);
        const length = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
        segments.push({ start, end, length });
        totalLength += length;
      }

      // Calculate number of arrows
      const numArrows = Math.floor(totalLength / ARROW_SPACING);
      if (numArrows === 0) return;

      const spacing = totalLength / numArrows;

      // Create arrows
      let distanceCovered = spacing / 2; // Start at half spacing for even distribution
      let segmentIndex = 0;
      let segmentDistance = 0;

      for (let i = 0; i < numArrows; i++) {
        // Find the right segment
        while (segmentDistance + segments[segmentIndex].length < distanceCovered) {
          segmentDistance += segments[segmentIndex].length;
          segmentIndex++;
          if (segmentIndex >= segments.length) return;
        }

        // Calculate position within segment
        const segment = segments[segmentIndex];
        const segmentPosition = (distanceCovered - segmentDistance) / segment.length;
        const x = segment.start.x + (segment.end.x - segment.start.x) * segmentPosition;
        const y = segment.start.y + (segment.end.y - segment.start.y) * segmentPosition;

        // Calculate angle
        const angle = Math.atan2(segment.end.y - segment.start.y, segment.end.x - segment.start.x);

        // Create arrow element
        const arrow = document.createElement('div');
        arrow.className = 'direction-arrow';
        arrow.style.position = 'absolute';
        arrow.style.left = `${x}px`;
        arrow.style.top = `${y}px`;
        arrow.style.width = '16px';
        arrow.style.height = '16px';
        arrow.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;

        // Create SVG arrow
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 16 16');
        svg.style.width = '100%';
        svg.style.height = '100%';

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M0,8 L12,8 M8,4 L12,8 L8,12');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('fill', 'none');

        svg.appendChild(path);
        arrow.appendChild(svg);
        document.getElementById('map').appendChild(arrow);

        distanceCovered += spacing;
      }
    }

    // const originalAddPolyline = addPolyline;
    // addPolyline = function() {
    //   originalAddPolyline();
    //   addDirectionArrows();
    // };


    const dateTimeInputs = document.querySelectorAll('#fromDate, #toDate, #fromTime, #toTime');
    dateTimeInputs.forEach(input => {
      input.addEventListener('change', () => {
        // Reset device selection
        document.getElementById('selectedVehicle').textContent = 'Select Vehicle';

        // Stop any ongoing playback
        stopPlayback();

        // Clear any existing data
        playbackData = [];
        dynamicPlaybackData = [];

        // Reset the dropdown display
        const dropdown = document.getElementById('deviceDropdown');
        if (dropdown) {
          dropdown.style.display = 'none';
        }
      });
    });


    // Event listeners
    $(document).ready(() => {
      $("#navbar-container").load("../navbarola.html", () => {
        console.log("Navbar loaded.");
      });


      $("#startPlayback").on("click", startPlayback);
      $("#pausePlayback").on("click", pausePlayback);
      $("#stopPlayback").on("click", stopPlayback);

      $("#deviceSelect").on("change", function () {
        const selectedDid = $(this).val();
        if (!selectedDid) return;

        // fetchPlaybackData(selectedDid).then(() => {
        //   if (playbackData.length) {
        //     addPolyline();
        //     addStartEndMarkers(pathCoordinates); // Replace addEndpointMarker with this
        //   }
        // });
      });

      // Check if 'mid' is available in localStorage otherwise ri-direct login page
      if (!localStorage.getItem('token')) {
        // Redirect to login page if 'mid' is not found
        window.location.href = '../index.html';
      }
      setupDateValidation()
    });

    document.addEventListener('DOMContentLoaded', function () {
      // Get URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const deviceName = urlParams.get('device');
      const fromDate = urlParams.get('from');
      const toDate = urlParams.get('to');

      if (deviceName && fromDate && toDate) {
        const dateInputs = document.querySelectorAll('.date-input input[type="date"]');
        const timeInputs = document.querySelectorAll('.date-input input[type="time"]');

        if (dateInputs.length >= 2) {
          dateInputs[0].value = fromDate;
          dateInputs[1].value = toDate;
          timeInputs[0].value = '00:00';
          timeInputs[1].value = '23:59';
        }
        // Wait for the vehicle list to be populated
        const checkVehicleList = setInterval(() => {
          const vehicleList = document.getElementById('vehicleList');
          if (vehicleList && vehicleList.children.length > 0) {
            clearInterval(checkVehicleList);

            // Find and click the matching device in the list
            const deviceElements = vehicleList.querySelectorAll('.dropdown-item');
            for (const element of deviceElements) {
              if (element.textContent.trim() === deviceName) {
                element.click();
                break;
              }
            }
          }
        }, 100);

        // Add a timeout to prevent infinite checking
        setTimeout(() => clearInterval(checkVehicleList), 10000);
      }
    });



  </script>
</body>

</html>